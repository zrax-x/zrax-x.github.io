<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>VolgaCTF-2020-Keygreed-WP</title>
      <link href="/2020/04/17/VolgaCTF-Keygreed/"/>
      <url>/2020/04/17/VolgaCTF-Keygreed/</url>
      
        <content type="html"><![CDATA[<p>关于mov attack，可以参考这篇<a href="https://blog.csdn.net/qq_26060285/article/details/90482755" target="_blank" rel="noopener">博客</a></p><p>下面简单说说这道题</p><p>首先我们可以验证这个椭圆曲线是超奇异的(supersingular)，在这里 $p^2 - 1 = 0\mod p.order()$</p><blockquote><p>The MOV attack works by using the <a href="https://en.wikipedia.org/wiki/Weil_pairing" target="_blank" rel="noopener">Weil pairing</a> (e: $E[m]×E[m]→μ_m$) to translate solving the dlog in the elliptic curve group to solving it in the multiplicative group $μ_m$ (group of m-th roots of unity), where sub-exponential algorithms exist. </p><p>Then, working in $F_{p^k}$ (extension of $F_p$), take Q to be a point in $E[m]$ (group of m-torsion points), such that P,Q are linearly independent, which can be constructed. Finally, take $e(P,Q)$ and $e(xP,Q)=e(P,Q)^x$ (due to bilinearity of e) as a dlog instance over a fininte field (m-th roots of unity), this is true by the non-degeneracy of the Weil pairing.</p></blockquote><p>因此这里的关键就是找到点Q，然后便把问题转化为了一个离散对数问题，寻找点Q的步骤如下</p><ol><li>在$F_{p^k}$上随机选取一个点，记为$R$</li><li>计算$m=R.order()$</li><li>计算$d=gcd(m,P.order)$</li><li>得到$Q=(m//d)*R$</li></ol><p>得到$Q$后，由于$Q=k*P$，因此问题就变得简单了很多。</p><p>好了，到了这里，事实上我还是没有搞懂MOV attack的具体原理，也没有讲清楚这道题的具体解法。不过没关系，后续可以慢慢理解，而且我认为我已经把MOV attack中的最重要的一个环节简单的阐述了一下。</p><p>Anyway，如果想看看这道题的具体解法，可以参考这篇<a href="https://sectt.github.io/writeups/Volga20/crypto_keygreed/README" target="_blank" rel="noopener">WriteUp</a></p>]]></content>
      
      
      
        <tags>
            
            <tag> CTF </tag>
            
            <tag> 密码学 </tag>
            
            <tag> ECC </tag>
            
            <tag> MOV attack </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Linux下批量kill多个同名进程</title>
      <link href="/2020/04/16/Linux%E4%B8%8B%E6%89%B9%E9%87%8Fkill%E5%A4%9A%E4%B8%AA%E5%90%8C%E5%90%8D%E8%BF%9B%E7%A8%8B/"/>
      <url>/2020/04/16/Linux%E4%B8%8B%E6%89%B9%E9%87%8Fkill%E5%A4%9A%E4%B8%AA%E5%90%8C%E5%90%8D%E8%BF%9B%E7%A8%8B/</url>
      
        <content type="html"><![CDATA[<blockquote><p>循序渐进</p><p>第一步：ps -ef | grep [name] 筛选出同名的所有进程</p><p>第二步：ps -ef | grep [name] | grep -v grep 将第一步中的grep进程删除</p><p>第三步：ps -ef | grep [name] | grep -v grep | cut -c 1-5 截断获取所有的pid号，这里cut的作用就是截取，1-5的作用是根据下标取出pid号，类似于python的切片，需要根据实际情况来调整</p><p>第四步：ps -ef | grep [name] | grep -v grep | cut -c 1-5 | xargs kill -9 将之前的所有pid作为kill命令的参数 </p></blockquote>]]></content>
      
      
      
        <tags>
            
            <tag> Linux </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Linux终端控制打印字符的颜色</title>
      <link href="/2020/04/16/Linux%E7%BB%88%E7%AB%AF%E6%8E%A7%E5%88%B6%E6%89%93%E5%8D%B0%E5%AD%97%E7%AC%A6%E7%9A%84%E9%A2%9C%E8%89%B2/"/>
      <url>/2020/04/16/Linux%E7%BB%88%E7%AB%AF%E6%8E%A7%E5%88%B6%E6%89%93%E5%8D%B0%E5%AD%97%E7%AC%A6%E7%9A%84%E9%A2%9C%E8%89%B2/</url>
      
        <content type="html"><![CDATA[<blockquote><p>格式：\033[控制码;背景颜色;前景颜色m字符串\033[0m </p><p>注意：\033可以替换为\x1b，同指Esc</p><p>各个属性的范围不同，因此不会混淆</p><p>前景色：30-37</p><p>背景色：40-47</p><p>控制码：</p><p>\33[0m 关闭所有属性</p><p>\33[1m 设置高亮度</p><p>\33[4m 下划线</p><p>\33[5m 闪烁</p><p>\33[7m 反显</p><p>\33[8m 消隐</p><p>\33[nA 光标上移n行</p><p>\33[nB 光标下移n行</p><p>\33[nC 光标右移n行</p><p>\33[nD 光标左移n行</p><p>\33[y;xH设置光标位置</p><p>\33[2J 清屏</p><p>\33[K 清除从光标到行尾的内容</p><p>\33[s 保存光标位置</p><p>\33[u 恢复光标位置</p><p>\33[?25l 隐藏光标</p><p>\33[?25h 显示光标</p><p>以下为常用的三种类型<br>\x1b[1;31m字符串\x1b[0m    高亮红色字体（error）<br>\x1b[1;33m字符串\x1b[0m    高亮黄色字体（info）<br>\x1b[1;34m字符串\x1b[0m    高亮蓝色字体（debug）</p></blockquote>]]></content>
      
      
      
        <tags>
            
            <tag> Linux </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
